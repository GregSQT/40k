class StepLogger:
    """
    Step-by-step action logger for training debugging.
    Captures ALL actions that generate step increments per AI_TURN.md.
    """
    
    def __init__(self, output_file="train_step.log", enabled=False):
        self.output_file = output_file
        self.enabled = enabled
        self.step_count = 0
        self.action_count = 0
        # Per-episode counters
        self.episode_step_count = 0
        self.episode_action_count = 0
        
        if self.enabled:
            # Clear existing log file
            with open(self.output_file, 'w') as f:
                f.write("=== STEP-BY-STEP ACTION LOG ===\n")
                f.write("AI_TURN.md COMPLIANCE: Actions that increment episode_steps are logged\n")
                f.write("STEP INCREMENT ACTIONS: move, shoot, charge, combat, wait (SUCCESS OR FAILURE)\n")
                f.write("NO STEP INCREMENT: auto-skip ineligible units, phase transitions\n")
                f.write("FAILED ACTIONS: Still increment steps - unit consumed time/effort\n")
                f.write("=" * 80 + "\n\n")
            print(f"ðŸ“ Step logging enabled: {self.output_file}")
    
    def log_action(self, unit_id, action_type, phase, player, success, step_increment, action_details=None):
        """Log action with step increment information using clear format"""
        if not self.enabled:
            return
            
        self.action_count += 1
        self.episode_action_count += 1
        if step_increment:
            self.step_count += 1
            self.episode_step_count += 1
            
        try:
            with open(self.output_file, 'a') as f:
                timestamp = time.strftime("%H:%M:%S", time.localtime())
                
                # Enhanced format: [timestamp] TX(col, row) PX PHASE : Message [SUCCESS/FAILED] [STEP: YES/NO]
                step_status = "STEP: YES" if step_increment else "STEP: NO"
                success_status = "SUCCESS" if success else "FAILED"
                phase_upper = phase.upper()
                
                # Format message using gameLogUtils.ts style
                message = self._format_replay_style_message(unit_id, action_type, action_details)
                
                # Standard format: [timestamp] TX PX PHASE : Message [SUCCESS/FAILED] [STEP: YES/NO]
                step_status = "STEP: YES" if step_increment else "STEP: NO"
                success_status = "SUCCESS" if success else "FAILED"
                phase_upper = phase.upper()
                
                # Get turn from SINGLE SOURCE OF TRUTH
                turn_number = action_details.get('current_turn', 1) if action_details else 1
                f.write(f"[{timestamp}] T{turn_number} P{player} {phase_upper} : {message} [{success_status}] [{step_status}]\n")
                
        except Exception as e:
            print(f"âš ï¸ Step logging error: {e}")
    
    def log_episode_start(self, units_data, scenario_info=None, bot_name=None, walls=None):
        """Log episode start with all unit starting positions and walls"""
        if not self.enabled:
            return

        # Reset per-episode counters
        self.episode_step_count = 0
        self.episode_action_count = 0

        # Use bot_name parameter or fall back to current_bot_name attribute
        effective_bot_name = bot_name or getattr(self, 'current_bot_name', None)

        try:
            with open(self.output_file, 'a') as f:
                timestamp = time.strftime("%H:%M:%S", time.localtime())
                f.write(f"\n[{timestamp}] === EPISODE START ===\n")

                if scenario_info:
                    f.write(f"[{timestamp}] Scenario: {scenario_info}\n")

                if effective_bot_name:
                    f.write(f"[{timestamp}] Opponent: {effective_bot_name.capitalize()}Bot\n")

                # Log walls/obstacles for replay
                if walls:
                    wall_coords = ";".join([f"({w['col']},{w['row']})" for w in walls])
                    f.write(f"[{timestamp}] Walls: {wall_coords}\n")
                else:
                    f.write(f"[{timestamp}] Walls: none\n")

                # Log all unit starting positions
                for unit in units_data:
                    if "id" not in unit:
                        raise KeyError("Unit missing required 'id' field")
                    if "col" not in unit:
                        raise KeyError(f"Unit {unit['id']} missing required 'col' field")
                    if "row" not in unit:
                        raise KeyError(f"Unit {unit['id']} missing required 'row' field")
                    if "player" not in unit:
                        raise KeyError(f"Unit {unit['id']} missing required 'player' field")

                    # Use unitType instead of name (name field doesn't exist)
                    unit_type = unit.get("unitType", "Unknown")
                    player_name = f"P{unit['player']}"
                    f.write(f"[{timestamp}] Unit {unit['id']} ({unit_type}) {player_name}: Starting position ({unit['col']}, {unit['row']})\n")

                f.write(f"[{timestamp}] === ACTIONS START ===\n")
                
        except Exception as e:
            print(f"âš ï¸ Episode start logging error: {e}")
    
    def _format_replay_style_message(self, unit_id, action_type, details):
        """Format messages with detailed combat info - enhanced replay format"""
        # Extract unit coordinates from action_details for consistent format
        unit_coords = ""
        if details and "unit_with_coords" in details:
            # Extract coordinates from format "3(12, 7)" -> "(12, 7)"
            coords_part = details["unit_with_coords"]
            if "(" in coords_part:
                coord_start = coords_part.find("(")
                unit_coords = coords_part[coord_start:]
        
        if action_type == "move" and details:
