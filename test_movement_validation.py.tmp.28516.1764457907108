#!/usr/bin/env python3
"""
Test script to reproduce the movement bug:
- Unit 1 at (23, 7) should NOT be able to move to (23, 2)
- Because enemy Unit 6 is at (23, 6), blocking the path

This simulates the exact scenario from train_step.log
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from engine.phase_handlers import movement_handlers

def test_movement_validation():
    """Test that movement through enemy-adjacent hexes is blocked."""

    # Create game state matching the bug scenario
    game_state = {
        "board_cols": 30,
        "board_rows": 20,
        "wall_hexes": set(),  # No walls for this test
        "units": [
            {
                "id": "unit_1",
                "player": 0,
                "col": 23,
                "row": 7,
                "HP_CUR": 10,
                "MOVE": 12,  # High movement to reach (23, 2)
                "unitType": "SpaceMarine"
            },
            {
                "id": "unit_6",
                "player": 1,
                "col": 23,
                "row": 6,  # Enemy blocking the path
                "HP_CUR": 10,
                "MOVE": 6,
                "unitType": "Ork"
            }
        ],
        "units_moved": set(),
        "units_fled": set(),
    }

    print("=" * 60)
    print("MOVEMENT VALIDATION TEST")
    print("=" * 60)
    print(f"Unit 1 (player 0) at (23, 7)")
    print(f"Enemy Unit 6 (player 1) at (23, 6)")
    print(f"Testing if Unit 1 can reach (23, 2)")
    print()

    # Build valid destinations using BFS
    movement_handlers.movement_build_valid_destinations_pool(game_state, "unit_1")
    valid_pool = game_state.get("valid_move_destinations_pool", [])

    print(f"Valid destinations pool size: {len(valid_pool)}")

    # Check if (23, 2) is in the pool
    target = (23, 2)
    if target in valid_pool:
        print(f"[BUG] (23, 2) IS in valid pool - pathfinding bug!")
    else:
        print(f"[OK] (23, 2) is NOT in valid pool - pathfinding correct")

    # Check which positions are reachable along column 23
    print()
    print("Positions reachable along column 23:")
    col_23_reachable = [(c, r) for c, r in valid_pool if c == 23]
    col_23_reachable.sort(key=lambda x: x[1])
    for pos in col_23_reachable:
        print(f"  {pos}")

    # Check which positions are blocked
    print()
    print("Expected blocked hexes (adjacent to enemy at (23,6)):")
    enemy_pos = (23, 6)
    neighbors = movement_handlers._get_hex_neighbors(enemy_pos[0], enemy_pos[1])
    for n in neighbors:
        print(f"  {n} - should be blocked for movement THROUGH")

    # Verify the enemy adjacency blocking
    print()
    print("Testing _is_hex_adjacent_to_enemy:")
    enemy_adjacent_hexes = movement_handlers._build_enemy_adjacent_hexes(game_state, 0)
    print(f"  Enemy adjacent hexes set: {enemy_adjacent_hexes}")

    test_positions = [(23, 5), (23, 7), (22, 6), (24, 6), (22, 5), (24, 5)]
    for pos in test_positions:
        is_adj = movement_handlers._is_hex_adjacent_to_enemy(
            game_state, pos[0], pos[1], 0, enemy_adjacent_hexes
        )
        status = "BLOCKED" if is_adj else "OK"
        print(f"  Position {pos}: {status}")

    print()
    print("=" * 60)

    # Now test the full validation flow
    print("FULL VALIDATION FLOW TEST")
    print("=" * 60)

    # Simulate what happens when AI tries to move to (23, 2)
    action = {
        "action": "move",
        "unitId": "unit_1",
        "destCol": 23,
        "destRow": 2
    }

    # Reset game state for validation
    game_state["valid_move_destinations_pool"] = []

    # Call the destination selection handler directly
    success, result = movement_handlers.movement_destination_selection_handler(
        game_state, "unit_1", action
    )

    print(f"Move to (23, 2) result:")
    print(f"  Success: {success}")
    print(f"  Result: {result}")

    if success:
        print()
        print("[BUG] Movement was ALLOWED when it should be BLOCKED!")
    else:
        print()
        print("[OK] Movement was correctly BLOCKED!")

    return not success  # Return True if test passed (movement blocked)

if __name__ == "__main__":
    passed = test_movement_validation()
    sys.exit(0 if passed else 1)
