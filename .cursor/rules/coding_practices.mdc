---
description: Bonnes pratiques de codage strictes - UniformitÃ©, pas de workaround, pas de fallback, erreurs explicites
globs: engine/**/*.py,ai/**/*.py
alwaysApply: true
---

# Bonnes Pratiques de Codage - RÃ¨gles Strictes

**OBJECTIF** : Garantir un code propre, cohÃ©rent et sans contournements.

## ðŸš¨ RÃˆGLES NON NÃ‰GOCIABLES

### 1. UniformitÃ© des CoordonnÃ©es (CRITIQUE)

**ProblÃ¨me** : Les coordonnÃ©es peuvent Ãªtre `int`, `float`, `str`, ou tuples inconsistants, causant des bugs subtils.

**RÃ¨gle** : TOUJOURS normaliser les coordonnÃ©es avant utilisation.

```python
# âŒ INTERDIT
def check_adjacency(unit, enemy):
    if unit["col"] == enemy["col"]:  # Comparaison directe non normalisÃ©e
        return True

# âœ… OBLIGATOIRE
from engine.combat_utils import normalize_coordinates, get_unit_coordinates

def check_adjacency(unit, enemy):
    unit_col, unit_row = get_unit_coordinates(unit)  # Normalise automatiquement
    enemy_col, enemy_row = get_unit_coordinates(enemy)
    # OU
    unit_col, unit_row = normalize_coordinates(unit["col"], unit["row"])
    enemy_col, enemy_row = normalize_coordinates(enemy["col"], enemy["row"])
    # Puis comparaison
```

**Fonctions Ã  utiliser** :
- `get_unit_coordinates(unit)` : Retourne `(int, int)` normalisÃ©
- `normalize_coordinates(col, row)` : Normalise n'importe quel format vers `(int, int)`

**VÃ©rifications obligatoires** :
- Avant toute comparaison de coordonnÃ©es
- Avant stockage dans des sets/tuples (clÃ©s de cache)
- Avant calcul de distance hexagonale
- Avant recherche dans `enemy_adjacent_hexes` (set de tuples)

### 2. Pas de Workaround

**DÃ©finition** : Solution temporaire qui contourne un problÃ¨me au lieu de le rÃ©soudre.

```python
# âŒ INTERDIT
# Workaround: Skip validation if data is None
if data is None:
    return default_value  # Contourne le problÃ¨me

# Workaround: Try-except pour masquer l'erreur
try:
    result = process(data)
except:
    result = None  # Masque l'erreur

# âœ… OBLIGATOIRE
# Corriger la root cause
if data is None:
    raise ValueError("data is required and cannot be None")

# GÃ©rer l'erreur explicitement
try:
    result = process(data)
except SpecificError as e:
    logger.error(f"Processing failed: {e}")
    raise  # Propager l'erreur, ne pas la masquer
```

**DÃ©tection** : Si le code contient des commentaires comme "workaround", "hack", "temporary fix", "TODO fix properly", c'est une violation.

### 3. Pas de Fallback Anti-Erreur

**DÃ©finition** : Valeur par dÃ©faut utilisÃ©e uniquement pour Ã©viter une erreur, sans justification mÃ©tier.

```python
# âŒ INTERDIT
value = config.get('key', None)  # Fallback silencieux
if not value:
    value = 0  # Fallback pour Ã©viter erreur

# Fallback dans calcul
distance = data.get('distance', 0)  # 0 n'a pas de sens mÃ©tier

# âœ… OBLIGATOIRE
# Utiliser require_key ou require_present
from shared.validation import require_key, require_present

value = require_key(config, 'key')  # LÃ¨ve KeyError si absent
value = require_present(raw_value, 'value')  # LÃ¨ve ValueError si None

# OU erreur explicite
if 'key' not in config:
    raise KeyError(f"Required config key 'key' is missing")
```

**Exception** : Les fallbacks sont autorisÃ©s UNIQUEMENT si c'est un comportement mÃ©tier valide (ex: stratÃ©gie de repli planifiÃ©e), JAMAIS pour contourner un bug.

### 4. Pas de Valeur par DÃ©faut Anti-Erreur

**DÃ©finition** : Valeur par dÃ©faut dont le seul objectif est d'Ã©viter une erreur si la variable n'existe pas.

```python
# âŒ INTERDIT
def process_unit(unit):
    hp = unit.get('HP_CUR', 0)  # 0 pour Ã©viter KeyError, pas pour logique mÃ©tier
    if hp > 0:  # Mais 0 n'est pas une valeur valide pour une unitÃ© vivante
        ...

# Cache avec fallback
cache = game_state.get('position_cache', {})  # {} pour Ã©viter KeyError

# âœ… OBLIGATOIRE
# Erreur explicite si valeur manquante
def process_unit(unit):
    if 'HP_CUR' not in unit:
        raise KeyError(f"Unit {unit.get('id')} missing required field HP_CUR")
    hp = unit['HP_CUR']
    if hp <= 0:
        raise ValueError(f"Unit {unit.get('id')} has invalid HP_CUR: {hp}")

# OU utiliser require_key
from shared.validation import require_key
hp = require_key(unit, 'HP_CUR')
```

**RÃ¨gle** : Si la valeur par dÃ©faut n'a pas de sens mÃ©tier, prÃ©fÃ©rer une erreur explicite.

### 5. Gestion d'Erreurs Explicite

**RÃ¨gle** : Toutes les erreurs doivent Ãªtre explicites et informatives.

```python
# âŒ INTERDIT
try:
    result = process(data)
except:
    pass  # Erreur silencieuse

except Exception:
    return None  # Erreur masquÃ©e

# âœ… OBLIGATOIRE
try:
    result = process(data)
except SpecificError as e:
    logger.error(f"Processing failed for {data}: {e}")
    raise ValueError(f"Cannot process data: {e}") from e
```

**Bonnes pratiques** :
- Capturer des exceptions spÃ©cifiques, pas `Exception` gÃ©nÃ©rique
- Logger l'erreur avec contexte
- Propager ou transformer en erreur explicite
- Utiliser `from e` pour chaÃ®ner les exceptions

### 6. Pas de Magic Numbers

**RÃ¨gle** : Toutes les valeurs numÃ©riques doivent provenir de configuration ou Ãªtre des constantes nommÃ©es.

```python
# âŒ INTERDIT
if distance > 5:  # Magic number
    reward = 10.0  # Magic number

# âœ… OBLIGATOIRE
max_range = config.get('max_shooting_range')  # Depuis config
base_reward = config.get('base_reward')  # Depuis config

# OU constantes nommÃ©es
MELEE_RANGE = 1  # Constante explicite
MAX_CHARGE_DISTANCE = 12  # Constante explicite
```

### 7. Type Hints Obligatoires

**RÃ¨gle** : Toutes les fonctions publiques doivent avoir des type hints.

```python
# âŒ INTERDIT
def process_unit(unit):
    return unit["id"]

# âœ… OBLIGATOIRE
from typing import Dict, Any, Optional, Tuple

def process_unit(unit: Dict[str, Any]) -> Optional[str]:
    return str(unit.get("id"))
```

### 8. Pas de VÃ©rification Redondante

**Principe** : Une fois un pool ou un cache construit (ex. `enemy_adjacent_hexes`, `valid_*_destinations_pool`), ne pas re-vÃ©rifier la mÃªme condition (adjacence, atteignabilitÃ©, etc.) ; le pool est la source de vÃ©ritÃ©.

```python
# âŒ INTERDIT
enemy_adjacent_hexes = game_state[cache_key]  # Construit au dÃ©but de phase
if is_adjacent_to_enemy(col, row):  # Re-vÃ©rification redondante

# âœ… OBLIGATOIRE
enemy_adjacent_hexes = game_state[cache_key]
if (col, row) in enemy_adjacent_hexes:  # S'appuyer sur le pool
```

**Exemples** : Ne pas appeler `is_adjacent_to_enemy(...)` aprÃ¨s avoir utilisÃ© `enemy_adjacent_hexes`. Ne pas re-valider atteignabilitÃ©/adjacence si la destination provient d'un `valid_*_destinations_pool` dÃ©jÃ  construit. Aucun check automatique pour l'instant ; rÃ¨gle de revue de code et documentation.

### 9. Docstrings pour Fonctions Publiques

**RÃ¨gle** : Toutes les fonctions publiques doivent avoir des docstrings.

```python
# âŒ INTERDIT
def check_adjacency(unit, enemy):
    return unit["col"] == enemy["col"]

# âœ… OBLIGATOIRE
def check_adjacency(unit: Dict[str, Any], enemy: Dict[str, Any]) -> bool:
    """
    Check if unit is adjacent to enemy unit.
    
    Args:
        unit: Unit dictionary with col/row coordinates
        enemy: Enemy unit dictionary with col/row coordinates
    
    Returns:
        True if units are adjacent (hex distance <= 1), False otherwise
    """
    unit_col, unit_row = get_unit_coordinates(unit)
    enemy_col, enemy_row = get_unit_coordinates(enemy)
    distance = calculate_hex_distance(unit_col, unit_row, enemy_col, enemy_row)
    return distance <= 1
```

## âœ… CHECKLIST DE VALIDATION

Avant de valider un changement, vÃ©rifier :

- [ ] CoordonnÃ©es normalisÃ©es avant toute utilisation
- [ ] Aucun workaround (pas de commentaires "workaround", "hack", "temporary")
- [ ] Aucun fallback anti-erreur (utiliser require_key/require_present)
- [ ] Aucune valeur par dÃ©faut anti-erreur (erreur explicite si valeur manquante)
- [ ] Gestion d'erreurs explicite (pas de `except: pass`)
- [ ] Aucun magic number (toutes depuis config ou constantes nommÃ©es)
- [ ] Type hints sur toutes les fonctions publiques
- [ ] Docstrings sur toutes les fonctions publiques
- [ ] Pas de vÃ©rification redondante (s'appuyer sur les pools/caches construits, ne pas re-vÃ©rifier)

## ðŸ”— RÃ‰FÃ‰RENCES

- **combat_utils.py** : Fonctions de normalisation de coordonnÃ©es
- **shared/validation.py** : `require_key`, `require_present` pour validation stricte
- **AI_TURN.md** : RÃ¨gles de conformitÃ© du jeu
