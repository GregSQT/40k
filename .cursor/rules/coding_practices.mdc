---
description: Bonnes pratiques de codage strictes - Uniformit√©, pas de workaround, pas de fallback, erreurs explicites
globs: engine/**/*.py,ai/**/*.py
alwaysApply: true
---

# Bonnes Pratiques de Codage - R√®gles Strictes

**OBJECTIF** : Garantir un code propre, coh√©rent et sans contournements.

## üö® R√àGLES NON N√âGOCIABLES

### 1. Uniformit√© des Coordonn√©es (CRITIQUE)

**Probl√®me** : Les coordonn√©es peuvent √™tre `int`, `float`, `str`, ou tuples inconsistants, causant des bugs subtils.

**R√®gle** : TOUJOURS normaliser les coordonn√©es avant utilisation.

```python
# ‚ùå INTERDIT
def check_adjacency(unit, enemy):
    if unit["col"] == enemy["col"]:  # Comparaison directe non normalis√©e
        return True

# ‚úÖ OBLIGATOIRE
from engine.combat_utils import normalize_coordinates, get_unit_coordinates

def check_adjacency(unit, enemy):
    unit_col, unit_row = get_unit_coordinates(unit)  # Normalise automatiquement
    enemy_col, enemy_row = get_unit_coordinates(enemy)
    # OU
    unit_col, unit_row = normalize_coordinates(unit["col"], unit["row"])
    enemy_col, enemy_row = normalize_coordinates(enemy["col"], enemy["row"])
    # Puis comparaison
```

**Fonctions √† utiliser** :
- `get_unit_coordinates(unit)` : Retourne `(int, int)` normalis√©
- `normalize_coordinates(col, row)` : Normalise n'importe quel format vers `(int, int)`

**V√©rifications obligatoires** :
- Avant toute comparaison de coordonn√©es
- Avant stockage dans des sets/tuples (cl√©s de cache)
- Avant calcul de distance hexagonale
- Avant recherche dans `enemy_adjacent_hexes` (set de tuples)

### 2. Pas de Workaround

**D√©finition** : Solution temporaire qui contourne un probl√®me au lieu de le r√©soudre.

```python
# ‚ùå INTERDIT
# Workaround: Skip validation if data is None
if data is None:
    return default_value  # Contourne le probl√®me

# Workaround: Try-except pour masquer l'erreur
try:
    result = process(data)
except:
    result = None  # Masque l'erreur

# ‚úÖ OBLIGATOIRE
# Corriger la root cause
if data is None:
    raise ValueError("data is required and cannot be None")

# G√©rer l'erreur explicitement
try:
    result = process(data)
except SpecificError as e:
    logger.error(f"Processing failed: {e}")
    raise  # Propager l'erreur, ne pas la masquer
```

**D√©tection** : Si le code contient des commentaires comme "workaround", "hack", "temporary fix", "TODO fix properly", c'est une violation.

### 3. Pas de Fallback Anti-Erreur

**D√©finition** : Valeur par d√©faut utilis√©e uniquement pour √©viter une erreur, sans justification m√©tier.

```python
# ‚ùå INTERDIT
value = config.get('key', None)  # Fallback silencieux
if not value:
    value = 0  # Fallback pour √©viter erreur

# Fallback dans calcul
distance = data.get('distance', 0)  # 0 n'a pas de sens m√©tier

# ‚úÖ OBLIGATOIRE
# Utiliser require_key ou require_present
from shared.validation import require_key, require_present

value = require_key(config, 'key')  # L√®ve KeyError si absent
value = require_present(raw_value, 'value')  # L√®ve ValueError si None

# OU erreur explicite
if 'key' not in config:
    raise KeyError(f"Required config key 'key' is missing")
```

**Exception** : Les fallbacks sont autoris√©s UNIQUEMENT si c'est un comportement m√©tier valide (ex: strat√©gie de repli planifi√©e), JAMAIS pour contourner un bug.

### 4. Pas de Valeur par D√©faut Anti-Erreur

**D√©finition** : Valeur par d√©faut dont le seul objectif est d'√©viter une erreur si la variable n'existe pas.

```python
# ‚ùå INTERDIT
def process_unit(unit):
    hp = unit.get('HP_CUR', 0)  # 0 pour √©viter KeyError, pas pour logique m√©tier
    if hp > 0:  # Mais 0 n'est pas une valeur valide pour une unit√© vivante
        ...

# Cache avec fallback
cache = game_state.get('units_cache', {})  # {} pour √©viter KeyError (INTERDIT si units_cache requis)

# ‚úÖ OBLIGATOIRE
# Erreur explicite si valeur manquante
def process_unit(unit):
    if 'HP_CUR' not in unit:
        raise KeyError(f"Unit {unit.get('id')} missing required field HP_CUR")
    hp = unit['HP_CUR']
    if hp <= 0:
        raise ValueError(f"Unit {unit.get('id')} has invalid HP_CUR: {hp}")

# OU utiliser require_key
from shared.validation import require_key
hp = require_key(unit, 'HP_CUR')
```

**R√®gle** : Si la valeur par d√©faut n'a pas de sens m√©tier, pr√©f√©rer une erreur explicite.

### 5. Gestion d'Erreurs Explicite

**R√®gle** : Toutes les erreurs doivent √™tre explicites et informatives.

```python
# ‚ùå INTERDIT
try:
    result = process(data)
except:
    pass  # Erreur silencieuse

except Exception:
    return None  # Erreur masqu√©e

# ‚úÖ OBLIGATOIRE
try:
    result = process(data)
except SpecificError as e:
    logger.error(f"Processing failed for {data}: {e}")
    raise ValueError(f"Cannot process data: {e}") from e
```

**Bonnes pratiques** :
- Capturer des exceptions sp√©cifiques, pas `Exception` g√©n√©rique
- Logger l'erreur avec contexte
- Propager ou transformer en erreur explicite
- Utiliser `from e` pour cha√Æner les exceptions

### 6. Pas de Magic Numbers

**R√®gle** : Toutes les valeurs num√©riques doivent provenir de configuration ou √™tre des constantes nomm√©es.

```python
# ‚ùå INTERDIT
if distance > 5:  # Magic number
    reward = 10.0  # Magic number

# ‚úÖ OBLIGATOIRE
max_range = config.get('max_shooting_range')  # Depuis config
base_reward = config.get('base_reward')  # Depuis config

# OU constantes nomm√©es
MELEE_RANGE = 1  # Constante explicite
MAX_CHARGE_DISTANCE = 12  # Constante explicite
```

### 7. Type Hints Obligatoires

**R√®gle** : Toutes les fonctions publiques doivent avoir des type hints.

```python
# ‚ùå INTERDIT
def process_unit(unit):
    return unit["id"]

# ‚úÖ OBLIGATOIRE
from typing import Dict, Any, Optional, Tuple

def process_unit(unit: Dict[str, Any]) -> Optional[str]:
    return str(unit.get("id"))
```

### 8. Pas de V√©rification Redondante

**Principe** : Une fois un pool ou un cache construit (ex. `enemy_adjacent_hexes`, `valid_*_destinations_pool`), ne pas re-v√©rifier la m√™me condition (adjacence, atteignabilit√©, etc.) ; le pool est la source de v√©rit√©.

```python
# ‚ùå INTERDIT
enemy_adjacent_hexes = game_state[cache_key]  # Construit au d√©but de phase
if is_adjacent_to_enemy(col, row):  # Re-v√©rification redondante

# ‚úÖ OBLIGATOIRE
enemy_adjacent_hexes = game_state[cache_key]
if (col, row) in enemy_adjacent_hexes:  # S'appuyer sur le pool
```

**Exemples** : Ne pas appeler `is_adjacent_to_enemy(...)` apr√®s avoir utilis√© `enemy_adjacent_hexes`. Ne pas re-valider atteignabilit√©/adjacence si la destination provient d'un `valid_*_destinations_pool` d√©j√† construit. Aucun check automatique pour l'instant ; r√®gle de revue de code et documentation.

### 9. HP_CUR et units_cache (source unique ‚Äî Phase 2)

**R√®gle** : En jeu, **seul** `update_units_cache_hp(game_state, unit_id, new_hp)` √©crit `HP_CUR` ; elle met √† jour **uniquement** `units_cache` (pas `unit["HP_CUR"]`). Si HP <= 0, elle appelle `remove_from_units_cache` (l'unit√© est retir√©e du cache). Ne jamais faire `unit["HP_CUR"] = ...` dans les handlers. Mort = **absent du cache**. Pour **lire** les HP : `get_hp_from_cache(unit_id, game_state)` (retourne `None` si mort/absent du cache). Pour ¬´ unit√© vivante ¬ª, utiliser `is_unit_alive(unit_id, game_state)` (pr√©sent dans le cache **et** `HP_CUR > 0`). **units_cache** est toujours pr√©sent apr√®s reset ; utiliser `require_key(game_state, "units_cache")` l√† o√π le cache est requis.

### 10. Docstrings pour Fonctions Publiques

**R√®gle** : Toutes les fonctions publiques doivent avoir des docstrings.

```python
# ‚ùå INTERDIT
def check_adjacency(unit, enemy):
    return unit["col"] == enemy["col"]

# ‚úÖ OBLIGATOIRE
def check_adjacency(unit: Dict[str, Any], enemy: Dict[str, Any]) -> bool:
    """
    Check if unit is adjacent to enemy unit.
    
    Args:
        unit: Unit dictionary with col/row coordinates
        enemy: Enemy unit dictionary with col/row coordinates
    
    Returns:
        True if units are adjacent (hex distance <= 1), False otherwise
    """
    unit_col, unit_row = get_unit_coordinates(unit)
    enemy_col, enemy_row = get_unit_coordinates(enemy)
    distance = calculate_hex_distance(unit_col, unit_row, enemy_col, enemy_row)
    return distance <= 1
```

## ‚úÖ CHECKLIST DE VALIDATION

Avant de valider un changement, v√©rifier :

- [ ] Coordonn√©es normalis√©es avant toute utilisation
- [ ] Aucun workaround (pas de commentaires "workaround", "hack", "temporary")
- [ ] Aucun fallback anti-erreur (utiliser require_key/require_present)
- [ ] Aucune valeur par d√©faut anti-erreur (erreur explicite si valeur manquante)
- [ ] Gestion d'erreurs explicite (pas de `except: pass`)
- [ ] Aucun magic number (toutes depuis config ou constantes nomm√©es)
- [ ] Type hints sur toutes les fonctions publiques
- [ ] Docstrings sur toutes les fonctions publiques
- [ ] Pas de v√©rification redondante (s'appuyer sur les pools/caches construits, ne pas re-v√©rifier)
- [ ] HP_CUR : √©criture uniquement via `update_units_cache_hp` (cache seul) ; lecture via `get_hp_from_cache` ; vivant via `is_unit_alive` (pas `HP_CUR > 0`)

## üîó R√âF√âRENCES

- **combat_utils.py** : Fonctions de normalisation de coordonn√©es
- **shared/validation.py** : `require_key`, `require_present` pour validation stricte
- **engine/phase_handlers/shared_utils.py** : `update_units_cache_hp`, `is_unit_alive`, `units_cache`
- **AI_TURN.md** : R√®gles de conformit√© du jeu
