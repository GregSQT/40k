---
description: ConformitÃ© stricte phase de combat - AI_TURN.md Fight Phase rules
globs: **/fight_handlers.py,**/fight*.py
alwaysApply: false
---

# Fight Phase Compliance - AI_TURN.md

**RÃ‰FÃ‰RENCE OBLIGATOIRE** : `Documentation/AI_TURN.md` Section "FIGHT PHASE LOGIC"

## ðŸš¨ INVARIANTS CRITIQUES DE PHASE

### Invariant 1 : Deux Joueurs Peuvent Agir (Unique Ã  Fight)

**RÃ¨gle** : Fight phase est la SEULE phase oÃ¹ les deux joueurs peuvent agir.

**Structure** :
1. **Sub-phase 1** : Charging units (joueur actuel) attaquent en premier
2. **Sub-phase 2** : Alternating fight (les deux joueurs alternent)

```python
# âŒ INTERDIT
def process_fight_phase(game_state):
    # Traiter uniquement current_player
    for unit in get_current_player_units(game_state):
        process_fight(unit)

# âœ… OBLIGATOIRE
def process_fight_phase(game_state):
    # Sub-phase 1: Charging units (current_player)
    process_charging_units(game_state)
    # Sub-phase 2: Alternating fight (both players)
    process_alternating_fight(game_state)
```

### Invariant 2 : Sequential Resolution

**RÃ¨gle** : Une unitÃ© complÃ¨te toutes ses attaques avant que la suivante ne commence.

```python
# âŒ INTERDIT
for unit in eligible_units:
    for attack in range(unit["ATTACK_LEFT"]):
        process_attack(unit)  # Toutes les unitÃ©s attaquent simultanÃ©ment

# âœ… OBLIGATOIRE
while fight_activation_pool:
    unit = fight_activation_pool[0]
    while unit["ATTACK_LEFT"] > 0:
        process_attack(unit)
        unit["ATTACK_LEFT"] -= 1
    # UnitÃ© complÃ¨te avant de passer Ã  la suivante
```

## ðŸ“‹ RÃˆGLES DE PHASE SPÃ‰CIFIQUES

### RÃ¨gle 1 : Sub-Phase 1 - Charging Units Priority

**RÃ¨gle** : UnitÃ©s qui ont chargÃ© (`units_charged`) attaquent EN PREMIER.

**Eligibility** :
- UnitÃ© vivante : `is_unit_alive(str(unit["id"]), game_state)` (source : `units_cache`)
- `unit.player === current_player`
- `unit.id in units_charged`
- Adjacent Ã  ennemi

```python
# âŒ INTERDIT
def get_charging_units(game_state):
    return [u for u in game_state["units"] if u["HP_CUR"] > 0]  # Utiliser is_unit_alive

# âœ… OBLIGATOIRE
from engine.phase_handlers.shared_utils import is_unit_alive
def get_charging_units(game_state):
    current_player = game_state["current_player"]
    charging_units = []
    for unit in game_state["units"]:
        if not is_unit_alive(str(unit["id"]), game_state):
            continue
        if unit["player"] != current_player:
            continue
        if unit["id"] not in game_state["units_charged"]:
            continue  # CRITICAL: Only charging units
        if not is_adjacent_to_enemy(unit, game_state):
            continue
        charging_units.append(unit["id"])
    return charging_units
```

### RÃ¨gle 2 : Sub-Phase 2 - Alternating Fight

**RÃ¨gle** : AprÃ¨s sub-phase 1, les unitÃ©s restantes alternent entre joueurs.

**Alternance** :
- Commence par le joueur **non actif**
- Puis `current_player`
- Puis le joueur **non actif** Ã  nouveau
- Continue jusqu'Ã  ce qu'aucune unitÃ© ne soit Ã©ligible

```python
# âŒ INTERDIT
def process_alternating_fight(game_state):
    # Traiter uniquement current_player
    for unit in get_current_player_units(game_state):
        process_fight(unit)

# âœ… OBLIGATOIRE
def process_alternating_fight(game_state):
    current_player = game_state["current_player"]
    opponent = 1 - current_player
    
    # Alterner entre joueurs
    while True:
        # Non-active player first
        eligible = get_eligible_fight_units(game_state, opponent)
        if not eligible:
            break
        process_fight_unit(eligible[0], game_state)
        
        # Then current_player
        eligible = get_eligible_fight_units(game_state, current_player)
        if not eligible:
            break
        process_fight_unit(eligible[0], game_state)
```

### RÃ¨gle 3 : ATTACK_LEFT Management

**RÃ¨gle** : `ATTACK_LEFT` est initialisÃ© Ã  `CC_NB` et dÃ©crÃ©mentÃ© aprÃ¨s chaque attaque.

**Validation** : VÃ©rifier cibles valides avant chaque attaque (unitÃ©s peuvent mourir).

```python
# âŒ INTERDIT
def process_fight(unit, game_state):
    # Attaquer toutes les fois sans vÃ©rifier cibles
    for _ in range(unit["ATTACK_LEFT"]):
        attack_random_target(unit)

# âœ… OBLIGATOIRE
def process_fight(unit, game_state):
    unit["ATTACK_LEFT"] = unit["CC_NB"]  # Initialiser
    while unit["ATTACK_LEFT"] > 0:
        # VÃ©rifier cibles valides (peuvent avoir changÃ©)
        valid_targets = build_valid_target_pool(unit, game_state)
        if not valid_targets:
            break  # Plus de cibles
        # SÃ©lectionner et attaquer
        target = select_target(valid_targets)
        attack_sequence(unit, target, game_state)
        unit["ATTACK_LEFT"] -= 1
```

### RÃ¨gle 4 : Valid Target Pool Building

**RÃ¨gle** : Cibles valides = ennemis adjacents vivants (`is_unit_alive` ; source : `units_cache`).

**Recalcul** : Pool doit Ãªtre reconstruit avant chaque attaque (cibles peuvent mourir).

```python
# âŒ INTERDIT
def process_fight(unit, game_state):
    targets = build_valid_target_pool(unit, game_state)
    # Utiliser mÃªme pool pour toutes les attaques
    for target in targets:
        attack(unit, target)

# âœ… OBLIGATOIRE
def process_fight(unit, game_state):
    while unit["ATTACK_LEFT"] > 0:
        # Reconstruire pool avant CHAQUE attaque
        valid_targets = build_valid_target_pool(unit, game_state)
        if not valid_targets:
            break
        target = select_target(valid_targets)
        attack_sequence(unit, target, game_state)
        unit["ATTACK_LEFT"] -= 1
```

### RÃ¨gle 5 : Attack Sequence (CC)

**Signature** : `attack_sequence(CC)`

**Processus** :
1. SÃ©lectionner arme CC : `unit.CC_WEAPONS[selectedCcWeaponIndex]`
2. Hit roll : `hit_roll >= selected_weapon.ATK`
3. Wound roll : `wound_roll >= calculate_wound_target()`
4. Save roll : `save_roll >= calculate_save_target()`
5. Damage : lire HP depuis le cache (`get_hp_from_cache`), calculer `new_hp`, appeler `update_units_cache_hp(game_state, target_id, new_hp)` uniquement (Phase 2 : met Ã  jour uniquement `units_cache`).
6. Death check : si `new_hp <= 0`, `update_units_cache_hp` appelle `remove_from_units_cache` (unitÃ© retirÃ©e de `units_cache`). Capturer position cible **avant** dÃ©gÃ¢ts pour les logs.

```python
# âŒ INTERDIT
def attack_sequence(unit, target, game_state):
    total_damage = 0
    for hit in hits:
        total_damage += weapon.DMG
    update_units_cache_hp(game_state, str(target["id"]), max(0, target["HP_CUR"] - total_damage))  # Ne pas lire target["HP_CUR"]

# âœ… OBLIGATOIRE (Phase 2)
from engine.phase_handlers.shared_utils import require_hp_from_cache, update_units_cache_hp
def attack_sequence(unit, target, game_state):
    weapon = unit["CC_WEAPONS"][unit["selectedCcWeaponIndex"]]
    # ...
    # Save roll
    for _ in range(wounds):
        save_roll = roll_d6()
        if save_roll < calculate_save_target(target):
            failed_saves += 1
            target_hp = require_hp_from_cache(str(target["id"]), game_state)
            new_hp = max(0, target_hp - weapon.DMG)
            update_units_cache_hp(game_state, str(target["id"]), new_hp)
            # Mort = remove_from_units_cache (unitÃ© retirÃ©e du cache)
```

### RÃ¨gle 6 : End Activation Parameters

**Signature** : `end_activation(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)`

Pour fight :
- `Arg1` : `ACTION` (si attaquÃ©) | `NO` (si pas de cibles)
- `Arg2` : `1` (+step)
- `Arg3` : `FIGHT` (tracking)
- `Arg4` : `FIGHT` (pool removal)
- `Arg5` : `1` (log)
- `Arg6` : `1` (remove green circle)

```python
# âŒ INTERDIT
end_activation("action", 1, "fight", "fight", 0, 0)  # Strings au lieu de constantes

# âœ… OBLIGATOIRE
from engine.phase_handlers.shared_utils import ACTION, FIGHT, NO
if attacked:
    end_activation(ACTION, 1, FIGHT, FIGHT, 1, 1)
else:
    end_activation(NO, 1, PASS, FIGHT, 1, 1)
```

## âš ï¸ VIOLATIONS COMMUNES

### Violation 1 : Pas d'Alternance

```python
# âŒ DÃ‰TECTER
def process_fight_phase(game_state):
    # Traiter uniquement current_player
    for unit in get_current_player_units(game_state):
        process_fight(unit)

# âœ… CORRECTION
# ImplÃ©menter alternance entre joueurs
```

### Violation 2 : Pool Non Reconstruit

```python
# âŒ DÃ‰TECTER
def process_fight(unit, game_state):
    targets = build_valid_target_pool(unit, game_state)
    # Utiliser mÃªme pool pour toutes les attaques
    for target in targets:
        attack(unit, target)

# âœ… CORRECTION
# Reconstruire pool avant chaque attaque
```

### Violation 3 : Damage Non ImmÃ©diat

```python
# âŒ DÃ‰TECTER
def attack_sequence(unit, target, game_state):
    total_damage = calculate_total_damage()
    update_units_cache_hp(game_state, str(target["id"]), max(0, target["HP_CUR"] - total_damage))  # Ne pas lire target["HP_CUR"]

# âœ… CORRECTION (Phase 2)
# Lire HP depuis require_hp_from_cache ; appliquer dÃ©gÃ¢ts IMMÃ‰DIATEMENT aprÃ¨s chaque failed save
target_hp = require_hp_from_cache(str(target["id"]), game_state)
new_hp = max(0, target_hp - total_damage)
update_units_cache_hp(game_state, str(target["id"]), new_hp)
```

## âœ… CHECKLIST DE VALIDATION

Avant de valider un changement dans fight phase :

- [ ] Sub-phase 1: Charging units en premier
- [ ] Sub-phase 2: Alternance entre joueurs
- [ ] Activation sÃ©quentielle (une unitÃ© complÃ¨te avant la suivante)
- [ ] ATTACK_LEFT initialisÃ© Ã  CC_NB
- [ ] Pool de cibles reconstruit avant chaque attaque
- [ ] Damage appliquÃ© immÃ©diatement (pas Ã  la fin)
- [ ] End activation avec bonnes constantes
- [ ] CoordonnÃ©es normalisÃ©es avant utilisation

## ðŸ”— RÃ‰FÃ‰RENCES

- **AI_TURN.md** : Section "FIGHT PHASE LOGIC" (lignes 1795-2750)
- **fight_handlers.py** : ImplÃ©mentation de rÃ©fÃ©rence
- **shared_utils.py** : Constantes pour end_activation
