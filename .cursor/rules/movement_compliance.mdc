---
description: ConformitÃ© stricte phase de mouvement - AI_TURN.md Movement Phase rules
globs: **/movement_handlers.py,**/movement*.py
alwaysApply: false
---

# Movement Phase Compliance - AI_TURN.md

**RÃ‰FÃ‰RENCE OBLIGATOIRE** : `Documentation/AI_TURN.md` Section "MOVEMENT PHASE Decision Tree"

## ðŸš¨ INVARIANTS CRITIQUES DE PHASE

### Invariant 1 : Current Player Ne Change Pas Pendant la Phase

**RÃ¨gle ABSOLUE** : Pendant la phase de mouvement d'un joueur, `current_player` ne change JAMAIS.

**Implications** :
- Les positions ennemies ne changent PAS (l'adversaire ne bouge pas)
- Les hex adjacents aux ennemis ne changent PAS
- Les caches (`enemy_adjacent_hexes`) ne deviennent PAS obsolÃ¨tes Ã  cause de mouvements ennemis

```python
# âŒ VIOLATION CRITIQUE
def build_valid_destinations(unit, game_state):
    # Recalculer "par sÃ©curitÃ©" car ennemis pourraient avoir bougÃ©
    enemy_adjacent_hexes = build_enemy_adjacent_hexes(game_state, unit["player"])
    # ERREUR : Les ennemis ne bougent PAS pendant la phase de mouvement du joueur actuel

# âœ… CORRECT
def build_valid_destinations(unit, game_state):
    # Utiliser le cache construit au dÃ©but de phase
    cache_key = f"enemy_adjacent_hexes_player_{game_state['current_player']}"
    if cache_key not in game_state:
        # Construire UNE FOIS au dÃ©but de phase
        game_state[cache_key] = build_enemy_adjacent_hexes(game_state, game_state['current_player'])
    enemy_adjacent_hexes = game_state[cache_key]
    # Le cache reste valide pendant TOUTE la phase
```

### Invariant 2 : Sequential Activation (Un Seul Ã  la Fois)

**RÃ¨gle** : Une seule unitÃ© active Ã  la fois. Les autres unitÃ©s attendent.

```python
# âŒ INTERDIT
for unit in eligible_units:
    process_movement(unit)  # Actions simultanÃ©es

# âœ… OBLIGATOIRE
if move_activation_pool:
    unit = move_activation_pool[0]
    process_movement(unit)  # Un seul Ã  la fois
```

## ðŸ“‹ RÃˆGLES DE PHASE SPÃ‰CIFIQUES

### RÃ¨gle 1 : Eligibility Check (Pool Building)

**Conditions OBLIGATOIRES** (toutes doivent Ãªtre vraies) :
- `unit.HP_CUR > 0` (unitÃ© vivante)
- `unit.player === current_player` (bon joueur)
- Au moins un hex de destination valide disponible

**Destinations VALIDES** :
- Non occupÃ©
- Non adjacent Ã  ennemi
- Non mur
- Atteignable via BFS pathfinding dans `MOVE` distance

```python
# âŒ INTERDIT
if unit["HP_CUR"] > 0:
    add_to_pool(unit)  # Manque vÃ©rifications

# âœ… OBLIGATOIRE
def get_eligible_units(game_state):
    eligible = []
    current_player = game_state["current_player"]
    for unit in game_state["units"]:
        if unit["HP_CUR"] <= 0:
            continue
        if unit["player"] != current_player:
            continue
        # VÃ©rifier destinations valides
        valid_destinations = build_valid_destinations_pool(unit, game_state)
        if valid_destinations:
            eligible.append(unit["id"])
    return eligible
```

### RÃ¨gle 2 : Restrictions de Mouvement (CRITIQUE)

**Destinations INTERDITES** :
- Hex occupÃ© (autre unitÃ©)
- Hex adjacent Ã  ennemi (entrer en fight)
- Hex mur (terrain bloque)

**Pourquoi** :
- Spatial logic : objets physiques ne peuvent pas se chevaucher
- Engagement rules : adjacent = fight = phase diffÃ©rente
- Terrain realism : murs bloquent les chemins

```python
# âŒ INTERDIT
def is_valid_destination(col, row, game_state):
    if is_wall(col, row):
        return False
    # Manque vÃ©rification adjacent Ã  ennemi

# âœ… OBLIGATOIRE
def is_valid_destination(col, row, unit, game_state):
    # VÃ©rifier occupation
    if is_occupied(col, row, game_state):
        return False
    # VÃ©rifier adjacent Ã  ennemi (CRITIQUE)
    if is_hex_adjacent_to_enemy(col, row, unit["player"], game_state):
        return False
    # VÃ©rifier mur
    if (col, row) in game_state["wall_hexes"]:
        return False
    return True
```

### RÃ¨gle 3 : Flee Mechanics

**DÃ©clencheur** : Action de mouvement commencÃ©e depuis hex adjacent Ã  unitÃ© ennemie.

**ImplÃ©mentation** : VÃ©rifier position de dÃ©part, pas destination (restrictions empÃªchent destinations adjacentes).

```python
# âŒ INTERDIT
def process_move(unit, destination, game_state):
    move_unit(unit, destination)
    # VÃ©rifier adjacence Ã  destination (toujours False)
    if is_adjacent_to_enemy_at(destination, game_state):
        mark_fled(unit)

# âœ… OBLIGATOIRE
def process_move(unit, destination, game_state):
    # VÃ©rifier adjacence Ã  position de DÃ‰PART
    was_adjacent = is_adjacent_to_enemy(unit, game_state)
    move_unit(unit, destination)
    if was_adjacent:
        # Marquer comme FLED
        end_activation(ACTION, 1, FLED, MOVE, 1, 1)
    else:
        end_activation(ACTION, 1, MOVE, MOVE, 1, 1)
```

**ConsÃ©quences de FLED** :
- Shooting phase : Ne peut pas tirer (dÃ©sorganisÃ©)
- Charge phase : Ne peut pas charger (mauvaise position/morale)
- Fight phase : Peut combattre normalement
- DurÃ©e : Jusqu'Ã  la fin du tour actuel uniquement

### RÃ¨gle 4 : BFS Pathfinding

**RÃ¨gle** : Utiliser BFS pour trouver chemins valides dans `MOVE` distance.

**Contraintes BFS** :
- Pas Ã  travers murs
- Pas Ã  travers hex adjacents Ã  ennemis
- Pas Ã  travers hex occupÃ©s
- Distance <= `unit.MOVE`

```python
# âŒ INTERDIT
def get_reachable_hexes(unit, game_state):
    # Distance euclidienne simple (incorrect pour hex)
    max_distance = unit["MOVE"]
    return all_hexes_within_distance(unit, max_distance)

# âœ… OBLIGATOIRE
def get_reachable_hexes(unit, game_state):
    from engine.pathfinding import bfs_pathfinding
    start_col, start_row = get_unit_coordinates(unit)
    max_distance = unit["MOVE"]
    # BFS avec contraintes
    reachable = bfs_pathfinding(
        start=(start_col, start_row),
        max_distance=max_distance,
        game_state=game_state,
        avoid_walls=True,
        avoid_enemy_adjacent=True,
        avoid_occupied=True
    )
    return reachable
```

### RÃ¨gle 5 : End Activation Parameters

**Signature** : `end_activation(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)`

Pour mouvement normal :
- `Arg1` : `ACTION`
- `Arg2` : `1` (+step)
- `Arg3` : `MOVE` (tracking)
- `Arg4` : `MOVE` (pool removal)
- `Arg5` : `1` (log)
- `Arg6` : `1` (remove green circle)

Pour FLED :
- `Arg1` : `ACTION`
- `Arg2` : `1` (+step)
- `Arg3` : `FLED` (tracking : units_moved ET units_fled)
- `Arg4` : `MOVE` (pool removal)
- `Arg5` : `1` (log)
- `Arg6` : `1` (remove green circle)

```python
# âŒ INTERDIT
end_activation("action", 1, "move", "move", 0, 0)  # Strings au lieu de constantes

# âœ… OBLIGATOIRE
from engine.phase_handlers.shared_utils import ACTION, MOVE, FLED
if was_adjacent_to_enemy:
    end_activation(ACTION, 1, FLED, MOVE, 1, 1)
else:
    end_activation(ACTION, 1, MOVE, MOVE, 1, 1)
```

## âš ï¸ VIOLATIONS COMMUNES

### Violation 1 : Mouvement Vers Hex Adjacent Ennemi

```python
# âŒ DÃ‰TECTER
move_to(hex_adjacent_to_enemy)

# âœ… CORRECTION
# Restrictions de mouvement empÃªchent cela
assert not is_hex_adjacent_to_enemy(destination_col, destination_row, player, game_state)
```

### Violation 2 : Recalcul Inutile de Caches

```python
# âŒ DÃ‰TECTER
def build_valid_destinations(unit, game_state):
    # Recalculer "par sÃ©curitÃ©"
    enemy_adjacent_hexes = build_enemy_adjacent_hexes(game_state, unit["player"])
    # ERREUR : current_player n'a pas changÃ©
```

### Violation 3 : Flee DÃ©tectÃ© Ã  Destination

```python
# âŒ DÃ‰TECTER
def process_move(unit, destination, game_state):
    move_unit(unit, destination)
    if is_adjacent_to_enemy_at(destination, game_state):
        mark_fled(unit)  # Impossible, restrictions empÃªchent destinations adjacentes

# âœ… CORRECTION
# VÃ©rifier position de DÃ‰PART, pas destination
was_adjacent = is_adjacent_to_enemy(unit, game_state)  # Avant mouvement
```

## âœ… CHECKLIST DE VALIDATION

Avant de valider un changement dans movement phase :

- [ ] `current_player` ne change pas pendant la phase (pas de recalcul de caches)
- [ ] Activation sÃ©quentielle (un seul Ã  la fois)
- [ ] Restrictions de mouvement respectÃ©es (pas adjacent, pas occupÃ©, pas mur)
- [ ] BFS pathfinding avec contraintes correctes
- [ ] Flee dÃ©tectÃ© Ã  position de dÃ©part, pas destination
- [ ] End activation avec bonnes constantes (MOVE ou FLED)
- [ ] CoordonnÃ©es normalisÃ©es avant utilisation

## ðŸ”— RÃ‰FÃ‰RENCES

- **AI_TURN.md** : Section "MOVEMENT PHASE Decision Tree" (lignes 257-363)
- **movement_handlers.py** : ImplÃ©mentation de rÃ©fÃ©rence
- **shared_utils.py** : Constantes pour end_activation
