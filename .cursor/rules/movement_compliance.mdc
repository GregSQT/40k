---
description: Conformit√© stricte phase de mouvement - AI_TURN.md Movement Phase rules
globs: **/movement_handlers.py,**/movement*.py
alwaysApply: false
---

# Movement Phase Compliance - AI_TURN.md

**R√âF√âRENCE OBLIGATOIRE** : `Documentation/AI_TURN.md` Section "MOVEMENT PHASE Decision Tree"

## üö® INVARIANTS CRITIQUES DE PHASE

### Invariant 1 : Current Player Ne Change Pas Pendant la Phase

**R√®gle ABSOLUE** : Pendant la phase de mouvement d'un joueur, `current_player` ne change JAMAIS.

**Implications** :
- Les positions ennemies ne changent PAS (l'adversaire ne bouge pas)
- Les hex adjacents aux ennemis ne changent PAS
- Les caches (`enemy_adjacent_hexes`) ne deviennent PAS obsol√®tes √† cause de mouvements ennemis

```python
# ‚ùå VIOLATION CRITIQUE
def build_valid_destinations(unit, game_state):
    # Recalculer "par s√©curit√©" car ennemis pourraient avoir boug√©
    enemy_adjacent_hexes = build_enemy_adjacent_hexes(game_state, unit["player"])
    # ERREUR : Les ennemis ne bougent PAS pendant la phase de mouvement du joueur actuel

# ‚úÖ CORRECT
def build_valid_destinations(unit, game_state):
    # Utiliser le cache construit au d√©but de phase
    cache_key = f"enemy_adjacent_hexes_player_{game_state['current_player']}"
    if cache_key not in game_state:
        # Construire UNE FOIS au d√©but de phase
        game_state[cache_key] = build_enemy_adjacent_hexes(game_state, game_state['current_player'])
    enemy_adjacent_hexes = game_state[cache_key]
    # Le cache reste valide pendant TOUTE la phase
```

### Invariant 2 : Sequential Activation (Un Seul √† la Fois)

**R√®gle** : Une seule unit√© active √† la fois. Les autres unit√©s attendent.

```python
# ‚ùå INTERDIT
for unit in eligible_units:
    process_movement(unit)  # Actions simultan√©es

# ‚úÖ OBLIGATOIRE
if move_activation_pool:
    unit = move_activation_pool[0]
    process_movement(unit)  # Un seul √† la fois
```

## üìã R√àGLES DE PHASE SP√âCIFIQUES

### R√®gle 1 : Eligibility Check (Pool Building)

**Conditions OBLIGATOIRES** (toutes doivent √™tre vraies) :
- Unit√© vivante : `is_unit_alive(str(unit["id"]), game_state)` (source : `units_cache`)
- `unit.player === current_player` (bon joueur)
- Au moins un hex de destination valide disponible

**Destinations VALIDES** :
- Non occup√©
- Non adjacent √† ennemi
- Non mur
- Atteignable via BFS pathfinding dans `MOVE` distance

```python
# ‚ùå INTERDIT
if unit["HP_CUR"] > 0:
    add_to_pool(unit)  # Utiliser is_unit_alive

# ‚úÖ OBLIGATOIRE
from engine.phase_handlers.shared_utils import is_unit_alive
def get_eligible_units(game_state):
    eligible = []
    current_player = game_state["current_player"]
    for unit in game_state["units"]:
        if not is_unit_alive(str(unit["id"]), game_state):
            continue
        if unit["player"] != current_player:
            continue
        # V√©rifier destinations valides
        valid_destinations = build_valid_destinations_pool(unit, game_state)
        if valid_destinations:
            eligible.append(unit["id"])
    return eligible
```

### R√®gle 2 : Restrictions de Mouvement (CRITIQUE)

**Destinations INTERDITES** :
- Hex occup√© (autre unit√©)
- Hex adjacent √† ennemi (entrer en fight)
- Hex mur (terrain bloque)

**Pourquoi** :
- Spatial logic : objets physiques ne peuvent pas se chevaucher
- Engagement rules : adjacent = fight = phase diff√©rente
- Terrain realism : murs bloquent les chemins

```python
# ‚ùå INTERDIT
def is_valid_destination(col, row, game_state):
    if is_wall(col, row):
        return False
    # Manque v√©rification adjacent √† ennemi

# ‚úÖ OBLIGATOIRE
def is_valid_destination(col, row, unit, game_state):
    # V√©rifier occupation
    if is_occupied(col, row, game_state):
        return False
    # V√©rifier adjacent √† ennemi (CRITIQUE)
    if is_hex_adjacent_to_enemy(col, row, unit["player"], game_state):
        return False
    # V√©rifier mur
    if (col, row) in game_state["wall_hexes"]:
        return False
    return True
```

### R√®gle 3 : Flee Mechanics

**D√©clencheur** : Action de mouvement commenc√©e depuis hex adjacent √† unit√© ennemie.

**Impl√©mentation** : V√©rifier position de d√©part, pas destination (restrictions emp√™chent destinations adjacentes).

```python
# ‚ùå INTERDIT
def process_move(unit, destination, game_state):
    move_unit(unit, destination)
    # V√©rifier adjacence √† destination (toujours False)
    if is_adjacent_to_enemy_at(destination, game_state):
        mark_fled(unit)

# ‚úÖ OBLIGATOIRE
def process_move(unit, destination, game_state):
    # V√©rifier adjacence √† position de D√âPART
    was_adjacent = is_adjacent_to_enemy(unit, game_state)
    move_unit(unit, destination)
    if was_adjacent:
        # Marquer comme FLED
        end_activation(ACTION, 1, FLED, MOVE, 1, 1)
    else:
        end_activation(ACTION, 1, MOVE, MOVE, 1, 1)
```

**Cons√©quences de FLED** :
- Shooting phase : Ne peut pas tirer (d√©sorganis√©)
- Charge phase : Ne peut pas charger (mauvaise position/morale)
- Fight phase : Peut combattre normalement
- Dur√©e : Jusqu'√† la fin du tour actuel uniquement

### R√®gle 4 : BFS Pathfinding

**R√®gle** : Utiliser BFS pour trouver chemins valides dans `MOVE` distance.

**Contraintes BFS** :
- Pas √† travers murs
- Pas √† travers hex adjacents √† ennemis
- Pas √† travers hex occup√©s
- Distance <= `unit.MOVE`

```python
# ‚ùå INTERDIT
def get_reachable_hexes(unit, game_state):
    # Distance euclidienne simple (incorrect pour hex)
    max_distance = unit["MOVE"]
    return all_hexes_within_distance(unit, max_distance)

# ‚úÖ OBLIGATOIRE
def get_reachable_hexes(unit, game_state):
    from engine.pathfinding import bfs_pathfinding
    start_col, start_row = get_unit_coordinates(unit)
    max_distance = unit["MOVE"]
    # BFS avec contraintes
    reachable = bfs_pathfinding(
        start=(start_col, start_row),
        max_distance=max_distance,
        game_state=game_state,
        avoid_walls=True,
        avoid_enemy_adjacent=True,
        avoid_occupied=True
    )
    return reachable
```

### R√®gle 5 : End Activation Parameters

**Signature** : `end_activation(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)`

Pour mouvement normal :
- `Arg1` : `ACTION`
- `Arg2` : `1` (+step)
- `Arg3` : `MOVE` (tracking)
- `Arg4` : `MOVE` (pool removal)
- `Arg5` : `1` (log)
- `Arg6` : `1` (remove green circle)

Pour FLED :
- `Arg1` : `ACTION`
- `Arg2` : `1` (+step)
- `Arg3` : `FLED` (tracking : units_moved ET units_fled)
- `Arg4` : `MOVE` (pool removal)
- `Arg5` : `1` (log)
- `Arg6` : `1` (remove green circle)

```python
# ‚ùå INTERDIT
end_activation("action", 1, "move", "move", 0, 0)  # Strings au lieu de constantes

# ‚úÖ OBLIGATOIRE
from engine.phase_handlers.shared_utils import ACTION, MOVE, FLED
if was_adjacent_to_enemy:
    end_activation(ACTION, 1, FLED, MOVE, 1, 1)
else:
    end_activation(ACTION, 1, MOVE, MOVE, 1, 1)
```

## ‚ö†Ô∏è VIOLATIONS COMMUNES

### Violation 1 : Mouvement Vers Hex Adjacent Ennemi

```python
# ‚ùå D√âTECTER
move_to(hex_adjacent_to_enemy)

# ‚úÖ CORRECTION
# Restrictions de mouvement emp√™chent cela
assert not is_hex_adjacent_to_enemy(destination_col, destination_row, player, game_state)
```

### Violation 2 : Recalcul Inutile de Caches

```python
# ‚ùå D√âTECTER
def build_valid_destinations(unit, game_state):
    # Recalculer "par s√©curit√©"
    enemy_adjacent_hexes = build_enemy_adjacent_hexes(game_state, unit["player"])
    # ERREUR : current_player n'a pas chang√©
```

### Violation 3 : Flee D√©tect√© √† Destination

```python
# ‚ùå D√âTECTER
def process_move(unit, destination, game_state):
    move_unit(unit, destination)
    if is_adjacent_to_enemy_at(destination, game_state):
        mark_fled(unit)  # Impossible, restrictions emp√™chent destinations adjacentes

# ‚úÖ CORRECTION
# V√©rifier position de D√âPART, pas destination
was_adjacent = is_adjacent_to_enemy(unit, game_state)  # Avant mouvement
```

## ‚úÖ CHECKLIST DE VALIDATION

Avant de valider un changement dans movement phase :

- [ ] `current_player` ne change pas pendant la phase (pas de recalcul de caches)
- [ ] Activation s√©quentielle (un seul √† la fois)
- [ ] Restrictions de mouvement respect√©es (pas adjacent, pas occup√©, pas mur)
- [ ] BFS pathfinding avec contraintes correctes
- [ ] Flee d√©tect√© √† position de d√©part, pas destination
- [ ] End activation avec bonnes constantes (MOVE ou FLED)
- [ ] Coordonn√©es normalis√©es avant utilisation

## üîó R√âF√âRENCES

- **AI_TURN.md** : Section "MOVEMENT PHASE Decision Tree" (lignes 257-363)
- **movement_handlers.py** : Impl√©mentation de r√©f√©rence
- **shared_utils.py** : Constantes pour end_activation
