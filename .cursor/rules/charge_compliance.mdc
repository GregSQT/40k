---
description: Conformit√© stricte phase de charge - AI_TURN.md Charge Phase rules
globs: **/charge_handlers.py,**/charge*.py
alwaysApply: false
---

# Charge Phase Compliance - AI_TURN.md

**R√âF√âRENCE OBLIGATOIRE** : `Documentation/AI_TURN.md` Section "CHARGE PHASE Decision Tree"

## üö® INVARIANTS CRITIQUES DE PHASE

### Invariant 1 : Current Player Ne Change Pas Pendant la Phase

**R√®gle ABSOLUE** : Pendant la phase de charge d'un joueur, `current_player` ne change JAMAIS.

**Implications** :
- Les positions ennemies ne changent PAS (l'adversaire ne bouge pas)
- Les hex adjacents aux ennemis ne changent PAS
- Les caches ne deviennent PAS obsol√®tes √† cause de mouvements ennemis

### Invariant 2 : Sequential Activation (Un Seul √† la Fois)

**R√®gle** : Une seule unit√© active √† la fois. Les autres unit√©s attendent.

## üìã R√àGLES DE PHASE SP√âCIFIQUES

### R√®gle 1 : Eligibility Check (Pool Building)

**Conditions OBLIGATOIRES** (toutes doivent √™tre vraies) :
- Unit√© vivante : `is_unit_alive(str(unit["id"]), game_state)` (source : `units_cache`)
- `unit.player === current_player` (bon joueur)
- `unit.id NOT in units_fled` (pas fui)
- `unit.id NOT in units_advanced` (pas avanc√© - ne peut pas charger apr√®s advance)
- `NOT adjacent to enemy` (pas d√©j√† en fight)
- Ennemis existent dans `charge_max_distance` ET ont hex adjacents non occup√©s √† ‚â§12 hexes

```python
# ‚ùå INTERDIT
if unit["HP_CUR"] > 0:
    add_to_pool(unit)  # Utiliser is_unit_alive

# ‚úÖ OBLIGATOIRE
from engine.phase_handlers.shared_utils import is_unit_alive
def get_eligible_units(game_state):
    eligible = []
    current_player = game_state["current_player"]
    for unit in game_state["units"]:
        if not is_unit_alive(str(unit["id"]), game_state):
            continue
        if unit["player"] != current_player:
            continue
        if unit["id"] in game_state["units_fled"]:
            continue
        if unit["id"] in game_state["units_advanced"]:
            continue  # CRITICAL: Advanced units cannot charge
        if is_adjacent_to_enemy(unit, game_state):
            continue  # Already in fight
        # V√©rifier cibles de charge valides
        if has_valid_charge_targets(unit, game_state):
            eligible.append(unit["id"])
    return eligible
```

### R√®gle 2 : Advanced Units Cannot Charge (CRITIQUE)

**R√®gle** : Unit√©s qui ont avanc√© (`units_advanced`) NE PEUVENT PAS charger.

```python
# ‚ùå INTERDIT
if unit["id"] in game_state["units_advanced"]:
    # Permettre charge quand m√™me
    process_charge(unit)

# ‚úÖ OBLIGATOIRE
if unit["id"] in game_state["units_advanced"]:
    continue  # Skip, cannot charge after advance
```

### R√®gle 3 : Charge Distance Logic (2D6 Roll)

**Quand rouler** : Imm√©diatement quand l'unit√© est s√©lectionn√©e par son joueur (pas quand action choisie).

**Dur√©e du roll** : La valeur du roll est **discard√©e** √† la fin de l'activation de l'unit√©.

**M√©canique** :
- Roll 2D6 ‚Üí `charge_range`
- Distance √† v√©rifier : distance au hex adjacent le plus proche √† la cible (via pathfinding)
- Roll doit √™tre ‚â• distance pour r√©ussir

```python
# ‚ùå INTERDIT
def process_charge(unit, target, game_state):
    # Roll apr√®s s√©lection de destination
    charge_range = roll_2d6()
    if charge_range >= distance:
        move_to_destination()

# ‚úÖ OBLIGATOIRE
def select_unit_for_charge(unit, game_state):
    # Roll IMM√âDIATEMENT √† la s√©lection
    charge_range = roll_2d6()
    game_state["charge_rolls"][unit["id"]] = charge_range
    # Puis s√©lection de cible et destination
    # Roll est discard√© √† la fin de l'activation
```

### R√®gle 4 : Valid Charge Destinations

**Conditions OBLIGATOIRES** :
- Adjacent √† la cible s√©lectionn√©e
- Distance ‚â§ `charge_range` (via BFS pathfinding)
- Non occup√©

```python
# ‚ùå INTERDIT
def build_charge_destinations(unit, target, charge_range, game_state):
    # Distance euclidienne (incorrect)
    all_adjacent = get_adjacent_hexes(target)
    return [h for h in all_adjacent if euclidean_distance(unit, h) <= charge_range]

# ‚úÖ OBLIGATOIRE
def build_charge_destinations(unit, target, charge_range, game_state):
    from engine.pathfinding import bfs_pathfinding
    target_adjacent_hexes = get_hex_neighbors(target["col"], target["row"])
    unit_col, unit_row = get_unit_coordinates(unit)
    valid_destinations = []
    for dest_col, dest_row in target_adjacent_hexes:
        # V√©rifier occupation
        if is_occupied(dest_col, dest_row, game_state):
            continue
        # V√©rifier distance via BFS
        distance = bfs_pathfinding_distance(
            start=(unit_col, unit_row),
            end=(dest_col, dest_row),
            game_state=game_state
        )
        if distance <= charge_range:
            valid_destinations.append((dest_col, dest_row))
    return valid_destinations
```

### R√®gle 5 : Charge Roll Discard

**R√®gle** : Le roll de charge est **discard√©** √† la fin de l'activation, qu'il ait √©t√© utilis√© ou non.

```python
# ‚ùå INTERDIT
def end_charge_activation(unit, game_state):
    # Garder le roll pour la prochaine activation
    # game_state["charge_rolls"][unit["id"]] reste

# ‚úÖ OBLIGATOIRE
def end_charge_activation(unit, game_state):
    # Discarder le roll
    if unit["id"] in game_state.get("charge_rolls", {}):
        del game_state["charge_rolls"][unit["id"]]
    end_activation(ACTION, 1, CHARGE, CHARGE, 1, 1)
```

### R√®gle 6 : End Activation Parameters

**Signature** : `end_activation(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)`

Pour charge r√©ussie :
- `Arg1` : `ACTION`
- `Arg2` : `1` (+step)
- `Arg3` : `CHARGE` (tracking)
- `Arg4` : `CHARGE` (pool removal)
- `Arg5` : `1` (log)
- `Arg6` : `1` (remove green circle)

```python
# ‚ùå INTERDIT
end_activation("action", 1, "charge", "charge", 0, 0)  # Strings au lieu de constantes

# ‚úÖ OBLIGATOIRE
from engine.phase_handlers.shared_utils import ACTION, CHARGE
end_activation(ACTION, 1, CHARGE, CHARGE, 1, 1)
```

## ‚ö†Ô∏è VIOLATIONS COMMUNES

### Violation 1 : Charge Apr√®s Advance

```python
# ‚ùå D√âTECTER
unit.advance()
unit.charge()  # Impossible apr√®s advance

# ‚úÖ CORRECTION
# units_advanced emp√™che cela
assert unit_id not in game_state["units_advanced"]
```

### Violation 2 : Charge Depuis Position Adjacente

```python
# ‚ùå D√âTECTER
if is_adjacent_to_enemy(unit, game_state):
    charge()  # D√©j√† adjacent

# ‚úÖ CORRECTION
# Pas de charge si d√©j√† adjacent
assert not is_adjacent_to_enemy(unit, game_state)
```

### Violation 3 : Roll Apr√®s S√©lection Destination

```python
# ‚ùå D√âTECTER
def process_charge(unit, destination, game_state):
    charge_range = roll_2d6()  # Roll trop tard
    if can_reach(destination, charge_range):
        move_to(destination)

# ‚úÖ CORRECTION
# Roll √† la s√©lection d'unit√©, pas √† la destination
charge_range = roll_2d6()  # √Ä la s√©lection
# Puis s√©lection cible et destination
```

## ‚úÖ CHECKLIST DE VALIDATION

Avant de valider un changement dans charge phase :

- [ ] `current_player` ne change pas pendant la phase
- [ ] Activation s√©quentielle (un seul √† la fois)
- [ ] Advanced units ne peuvent pas charger
- [ ] Pas adjacent √† ennemi (pas d√©j√† en fight)
- [ ] Roll 2D6 √† la s√©lection d'unit√©, pas √† la destination
- [ ] Roll discard√© √† la fin de l'activation
- [ ] Destinations valides (adjacent √† cible, distance ‚â§ roll, non occup√©)
- [ ] BFS pathfinding pour distance
- [ ] End activation avec bonnes constantes
- [ ] Coordonn√©es normalis√©es avant utilisation

## üîó R√âF√âRENCES

- **AI_TURN.md** : Section "CHARGE PHASE Decision Tree" (lignes 1660-1793)
- **charge_handlers.py** : Impl√©mentation de r√©f√©rence
- **shared_utils.py** : Constantes pour end_activation
