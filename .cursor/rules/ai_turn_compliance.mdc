---
description: V√©rification stricte de conformit√© avec AI_TURN.md - Contrat de codage et r√®gles critiques
globs: engine/**/*.py,ai/**/*.py
alwaysApply: true
---

# AI_TURN.md Compliance - R√®gles G√©n√©rales

**R√âF√âRENCE OBLIGATOIRE** : Avant toute modification du code, lire et v√©rifier la conformit√© avec :
- `Documentation/AI_TURN.md` (r√®gles de tour et phases)
- `Documentation/AI_IMPLEMENTATION.md` (architecture)

**R√àGLES SP√âCIALIS√âES** : Cette r√®gle g√©n√©rale est compl√©t√©e par des r√®gles sp√©cialis√©es par phase :
- `shooting_compliance.mdc` : Phase de tir
- `movement_compliance.mdc` : Phase de mouvement
- `charge_compliance.mdc` : Phase de charge
- `fight_compliance.mdc` : Phase de combat
- `coding_practices.mdc` : Bonnes pratiques g√©n√©rales (coordonn√©es, workaround, etc.)

## üö® CONTRAT DE CODAGE AI (NON N√âGOCIABLE)

### R√®gle 1 : Ne jamais assumer de valeurs
```python
# ‚ùå INTERDIT
if not config.get('learning_rate'):
    learning_rate = 0.001  # Valeur invent√©e

# ‚úÖ OBLIGATOIRE
learning_rate = require_key(config, 'learning_rate')  # L√®ve une erreur si absent
```

### R√®gle 2 : Toujours lever une erreur explicite
```python
# ‚ùå INTERDIT
value = data.get('key', None)  # Silent substitution
if not value:
    return  # Skip silencieux

# ‚úÖ OBLIGATOIRE
value = require_key(data, 'key')  # L√®ve KeyError si absent
if not value:
    raise ValueError("key is required and cannot be None")
```

### R√®gle 3 : Pas de constantes inline
```python
# ‚ùå INTERDIT
if distance > 5:  # Magic number
    reward = 10.0  # Magic number

# ‚úÖ OBLIGATOIRE
max_range = config.get('max_shooting_range')  # Depuis config
base_reward = config.get('base_reward')  # Depuis config
```

### R√®gle 4 : Design simple et conforme
- Pr√©f√©rer la plus petite impl√©mentation qui respecte AI_TURN.md
- √âviter les abstractions inutiles
- Refuser les changements qui violent AI_TURN.md

## üìã CONVENTIONS DE NOMMAGE (CRITIQUE)

### Champs UPPERCASE obligatoires
Tous les champs de statistiques d'unit√© DOIVENT √™tre en UPPERCASE :

```python
# ‚ùå INTERDIT
unit['hp_cur'] = 10
unit['move'] = 6
unit['rng_atk'] = 3

# ‚úÖ OBLIGATOIRE
unit['HP_CUR'] = 10
unit['MOVE'] = 6
unit['RNG_WEAPONS'] = [...]  # Tableau d'armes
unit['selectedRngWeaponIndex'] = 0  # Index (camelCase OK)
```

**Champs critiques √† v√©rifier** :
- Movement : `MOVE`, `col`, `row`
- Shooting : `RNG_WEAPONS[]`, `selectedRngWeaponIndex`, `SHOOT_LEFT`
- Fight : `CC_WEAPONS[]`, `selectedCcWeaponIndex`, `ATTACK_LEFT`
- Defense : `HP_CUR`, `HP_MAX`, `T`, `ARMOR_SAVE`, `INVUL_SAVE`

**‚ö†Ô∏è CRITICAL** : Utiliser `engine.utils.weapon_helpers` pour acc√©der aux armes (tableaux, pas champs uniques).

## üîÑ GESTION D'√âTAT (SINGLE SOURCE OF TRUTH)

### Principe : Un seul game_state
```python
# ‚ùå INTERDIT
def process_action(game_state):
    local_state = game_state.copy()  # Copie interdite
    local_state['step'] += 1

# ‚úÖ OBLIGATOIRE
def process_action(game_state):
    game_state['step'] += 1  # Modification directe
```

### Tracking Sets (OBLIGATOIRE)
Les sets de tracking DOIVENT √™tre mis √† jour via `end_activation()` :

```python
# Tracking sets critiques :
# - units_moved
# - units_shot
# - units_advanced
# - units_charged
# - units_fought
# - units_fled

# ‚ùå INTERDIT
unit['has_moved'] = True  # Tracking manuel

# ‚úÖ OBLIGATOIRE
end_activation(ACTION, 1, MOVE, MOVE, 0, 0)  # Marque automatiquement
```

## üéØ PHASES ET S√âQUENCES

### Activation s√©quentielle (UN SEUL √Ä LA FOIS)
```python
# ‚ùå INTERDIT
for unit in eligible_units:
    unit.act()  # Actions simultan√©es

# ‚úÖ OBLIGATOIRE
if move_activation_pool:
    unit = move_activation_pool[0]
    process_unit_activation(unit)  # Un seul √† la fois
```

### Fin de phase par √©ligibilit√©
```python
# ‚ùå INTERDIT
if step_count >= max_steps:
    end_phase()  # Fin arbitraire

# ‚úÖ OBLIGATOIRE
if not move_activation_pool:  # Pool vide = plus d'unit√©s √©ligibles
    advance_to_next_phase()
```

## üîç POINTS CRITIQUES (V√âRIFICATION OBLIGATOIRE)

### 1. Caches et Pools
```python
# ‚ùå INTERDIT
def build_target_pool(unit):
    targets = []  # Pas de v√©rification de cache
    for enemy in enemies:
        targets.append(enemy)

# ‚úÖ OBLIGATOIRE
def build_target_pool(unit):
    assert 'los_cache' in unit, "los_cache must exist (call build_unit_los_cache first)"
    assert 'units_cache' in game_state, "units_cache must exist (build_units_cache at reset)"
    # Utiliser los_cache pour performance
```

**R√®gles de cache** :
- `units_cache` : Source de v√©rit√© pour position et HP_CUR des unit√©s **vivantes** (mortes = absentes du cache). Construit au reset uniquement ; mis √† jour incr√©mentalement (position, HP). Mort ‚Üí `update_units_cache_hp(..., 0)` (l‚Äôentr√©e appelle remove_from_units_cache, unit√© retir√©e du cache).
- `los_cache` : Recalcul√© apr√®s chaque advance (pas juste invalid√©)
- `los_cache` : Nettoy√© √† la fin de l'activation
- Pool = source de v√©rit√©, cache = optimisation
- **HP_CUR** : Seul `update_units_cache_hp` √©crit HP_CUR en jeu (uniquement dans `units_cache`). Pour **lire** les HP : `get_hp_from_cache(unit_id, game_state)` (`None` si mort/absent du cache). Pas d'assignation directe √† `unit["HP_CUR"]`.
- **Vivant** : Utiliser `is_unit_alive(unit_id, game_state)` (pr√©sent dans le cache **et** HP_CUR > 0). Mort = absent du cache.

### 2. Fonction end_activation() - Arguments stricts
```python
# Signature : end_activation(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)
# Arg1 : ACTION | WAIT | NO (logging)
# Arg2 : 1 = +step | 0 = pas de step
# Arg3 : 0 | MOVE | FLED | SHOOTING | ADVANCE | CHARGE | FIGHT (tracking)
# Arg4 : NOT_REMOVED | MOVE | FLED | SHOOTING | CHARGE | FIGHT (pool removal)
# Arg5 : 1 = log error | 0 = pas de log
# Arg6 : 1 = remove green circle | 0 = keep circle

# ‚ùå INTERDIT
end_activation(ACTION, 1, "move", "move", 0, 0)  # Strings au lieu de constantes

# ‚úÖ OBLIGATOIRE
end_activation(ACTION, 1, MOVE, MOVE, 0, 0)  # Constantes d√©finies
```

### 3. Restrictions de mouvement
```python
# ‚ùå INTERDIT
if can_move_to(hex):
    move_unit(hex)  # Pas de v√©rification d'adjacence ennemie

# ‚úÖ OBLIGATOIRE
if not is_adjacent_to_enemy(hex) and can_move_to(hex):
    move_unit(hex)  # Interdit de bouger VERS hex adjacent √† ennemi
```

### 4. Restrictions de tir
```python
# Unit√©s adjacentes √† ennemis = EN FIGHT = NE PEUVENT PAS TIRER
# Sauf si arme PISTOL

# ‚ùå INTERDIT
if has_weapon():
    shoot()  # Pas de v√©rification d'adjacence

# ‚úÖ OBLIGATOIRE
if is_adjacent_to_enemy():
    if not has_pistol_weapon():
        return  # Ne peut pas tirer
    # Sinon, peut tirer avec PISTOL uniquement
```

### 5. Advance Action (Post-advance restrictions)
```python
# Apr√®s advance :
# - Seules les armes ASSAULT sont disponibles
# - valid_target_pool doit √™tre reconstruit
# - CAN_ADVANCE = false (ne peut plus avancer)

# ‚ùå INTERDIT
unit['CAN_ADVANCE'] = True  # Apr√®s avoir avanc√©
shoot_with_any_weapon()  # Pas de filtrage ASSAULT

# ‚úÖ OBLIGATOIRE
unit['CAN_ADVANCE'] = False  # Apr√®s advance
weapon_availability_check(weapon_rule, 1, 0)  # Filtre ASSAULT uniquement
valid_target_pool_build(weapon_rule, 1, 0)  # Reconstruit pool
```

## ‚ö†Ô∏è VIOLATIONS COMMUNES √Ä D√âTECTER

### Violation 1 : Double action dans m√™me phase
```python
# ‚ùå D√âTECTER
unit.shoot()
unit.shoot()  # M√™me unit√© tire deux fois

# ‚úÖ CORRECTION
# units_shot tracking emp√™che cela
assert unit_id not in game_state['units_shot']
```

### Violation 2 : Mouvement vers hex adjacent ennemi
```python
# ‚ùå D√âTECTER
move_to(hex_adjacent_to_enemy)

# ‚úÖ CORRECTION
# Restrictions de mouvement emp√™chent cela
assert not is_adjacent_to_enemy(destination)
```

### Violation 3 : Tir apr√®s avoir fui
```python
# ‚ùå D√âTECTER
unit.flee()
unit.shoot()  # Dans le m√™me tour

# ‚úÖ CORRECTION
# units_fled emp√™che le tir
if unit_id in game_state['units_fled']:
    return  # Ne peut pas tirer
```

### Violation 4 : Charge depuis position adjacente
```python
# ‚ùå D√âTECTER
if is_adjacent_to_enemy():
    charge()  # D√©j√† adjacent

# ‚úÖ CORRECTION
# Pas de charge si d√©j√† adjacent
assert not is_adjacent_to_enemy()
```

## ‚úÖ CHECKLIST DE VALIDATION

Avant de valider un changement, v√©rifier :

- [ ] Aucune valeur assum√©e (toutes depuis config ou erreur explicite)
- [ ] Aucun fallback silencieux (erreurs explicites uniquement)
- [ ] Aucune constante inline (toutes depuis config)
- [ ] Champs UPPERCASE respect√©s (HP_CUR, MOVE, etc.)
- [ ] Single source of truth (pas de copie de game_state)
- [ ] Tracking sets mis √† jour via end_activation()
- [ ] Activation s√©quentielle (un seul √† la fois)
- [ ] Fin de phase par √©ligibilit√© (pools vides)
- [ ] Caches v√©rifi√©s (los_cache, units_cache)
- [ ] Restrictions de mouvement respect√©es
- [ ] Restrictions de tir respect√©es (adjacence = fight)
- [ ] Advance restrictions respect√©es (ASSAULT uniquement apr√®s)
- [ ] Fonction end_activation() appel√©e avec bonnes constantes

## üîó R√âF√âRENCES

- **AI_TURN.md** : R√®gles compl√®tes de tour, phases, s√©quences
- **AI_IMPLEMENTATION.md** : Architecture et patterns d'impl√©mentation
- **Validation** : `shared/validation.py` pour require_key, require_present
- **Script de v√©rification** : `scripts/check_ai_rules.py` pour d√©tection automatique

## üìö R√àGLES SP√âCIALIS√âES PAR DOMAINE

Pour des r√®gles d√©taill√©es par phase, consulter :
- **shooting_compliance.mdc** : R√®gles sp√©cifiques phase de tir (caches, advance, etc.)
- **movement_compliance.mdc** : R√®gles sp√©cifiques phase de mouvement (flee, restrictions, etc.)
- **charge_compliance.mdc** : R√®gles sp√©cifiques phase de charge (roll 2D6, advanced units, etc.)
- **fight_compliance.mdc** : R√®gles sp√©cifiques phase de combat (alternance, charging priority, etc.)
- **coding_practices.mdc** : Bonnes pratiques g√©n√©rales (coordonn√©es, workaround, fallback, etc.)

## üéØ PRINCIPE FINAL

**Si une r√®gle dans AI_TURN.md n'est pas claire ou semble en conflit avec une demande :**
1. **ARR√äTER** l'impl√©mentation
2. **SIGNALER** le conflit explicitement
3. **DEMANDER** clarification avant de continuer

**Ne jamais impl√©menter une violation "temporaire" ou "workaround".**

**Utiliser les r√®gles sp√©cialis√©es** pour des v√©rifications d√©taill√©es par phase.
