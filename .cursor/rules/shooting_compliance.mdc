---
description: Conformit√© stricte phase de tir - AI_TURN.md Shooting Phase rules
globs: **/shooting_handlers.py,**/shooting*.py
alwaysApply: false
---

# Shooting Phase Compliance - AI_TURN.md

**R√âF√âRENCE OBLIGATOIRE** : `Documentation/AI_TURN.md` Section "SHOOTING PHASE Decision Tree"

## üö® INVARIANTS CRITIQUES DE PHASE

### Invariant 1 : Current Player Ne Change Pas Pendant la Phase

**R√®gle ABSOLUE** : Pendant la phase de tir d'un joueur, `current_player` ne change JAMAIS.

**Implications** :
- Les positions ennemies ne changent PAS (l'adversaire ne bouge pas)
- Les hex adjacents aux ennemis ne changent PAS
- Les caches (`enemy_adjacent_hexes`, `units_cache`) ne deviennent PAS obsol√®tes √† cause de mouvements ennemis

```python
# ‚ùå VIOLATION CRITIQUE
def build_target_pool(unit, game_state):
    # Recalculer "par s√©curit√©" car ennemis pourraient avoir boug√©
    enemy_adjacent_hexes = build_enemy_adjacent_hexes(game_state, unit["player"])
    # ERREUR : Les ennemis ne bougent PAS pendant la phase de tir du joueur actuel

# ‚úÖ CORRECT
def build_target_pool(unit, game_state):
    # Utiliser le cache construit au d√©but de phase
    cache_key = f"enemy_adjacent_hexes_player_{game_state['current_player']}"
    if cache_key not in game_state:
        # Construire UNE FOIS au d√©but de phase
        game_state[cache_key] = build_enemy_adjacent_hexes(game_state, game_state['current_player'])
    enemy_adjacent_hexes = game_state[cache_key]
    # Le cache reste valide pendant TOUTE la phase
```

**V√©rification** : Si le code recalcule `enemy_adjacent_hexes` ou `units_cache` sans changement de `current_player` ou de phase ‚Üí **VIOLATION**.

### Invariant 2 : Sequential Activation (Un Seul √† la Fois)

**R√®gle** : Une seule unit√© active √† la fois. Les autres unit√©s attendent.

```python
# ‚ùå INTERDIT
for unit in eligible_units:
    process_shooting(unit)  # Actions simultan√©es

# ‚úÖ OBLIGATOIRE
if shoot_activation_pool:
    unit = shoot_activation_pool[0]
    process_shooting(unit)  # Un seul √† la fois
```

### Invariant 3 : Caches Valides Pendant Toute l'Activation

**R√®gle** : `los_cache` et `units_cache` restent valides pendant toute l'activation d'une unit√©, sauf :
- Mort d'une cible ‚Üí `update_units_cache_hp(..., 0)` appelle `remove_from_units_cache` (unit√© retir√©e de `units_cache`) ; retirer de `los_cache` (pas de recalcul). Capturer position cible **avant** d√©g√¢ts pour les logs.
- Advance de l'unit√© ‚Üí recalculer `los_cache` (nouvelle position)

```python
# ‚ùå INTERDIT
def update_after_target_death(dead_target_id, unit):
    # Recalculer tout le cache
    unit["los_cache"] = build_unit_los_cache(unit)  # Inutile, co√ªteux

# ‚úÖ OBLIGATOIRE
def update_after_target_death(dead_target_id, unit, game_state):
    # Retirer uniquement la cible morte (units_cache d√©j√† mis √† jour par update_units_cache_hp)
    if dead_target_id in unit.get("los_cache", {}):
        del unit["los_cache"][dead_target_id]
    # units_cache : retrait via update_units_cache_hp(..., 0) au moment des d√©g√¢ts
    # Pas de recalcul, juste retrait
```

## üìã R√àGLES DE PHASE SP√âCIFIQUES

### R√®gle 1 : Eligibility Check (Pool Building)

**Conditions OBLIGATOIRES** (toutes doivent √™tre vraies) :
- Unit√© vivante : `is_unit_alive(str(unit["id"]), game_state)` (source : `units_cache`)
- `unit.player === current_player` (bon joueur)
- `unit.id NOT in units_shot` (pas d√©j√† tir√©)
- Au moins une cible valide disponible

```python
# ‚ùå INTERDIT
if unit["HP_CUR"] > 0:
    add_to_pool(unit)  # Utiliser is_unit_alive, pas HP_CUR

# ‚úÖ OBLIGATOIRE
from engine.phase_handlers.shared_utils import is_unit_alive
def get_eligible_units(game_state):
    eligible = []
    current_player = game_state["current_player"]
    for unit in game_state["units"]:
        if not is_unit_alive(str(unit["id"]), game_state):
            continue
        if unit["player"] != current_player:
            continue
        if unit["id"] in game_state["units_shot"]:
            continue
        # V√©rifier cibles valides...
        if has_valid_targets(unit, game_state):
            eligible.append(unit["id"])
    return eligible
```

### R√®gle 2 : Adjacent = In Fight = Cannot Shoot

**R√®gle** : Unit√©s adjacentes √† ennemis = EN FIGHT = NE PEUVENT PAS TIRER (sauf PISTOL).

```python
# ‚ùå INTERDIT
if has_weapon(unit):
    shoot()  # Pas de v√©rification d'adjacence

# ‚úÖ OBLIGATOIRE
if is_adjacent_to_enemy(unit, game_state):
    if not has_pistol_weapon(unit):
        return  # Ne peut pas tirer
    # Sinon, peut tirer avec PISTOL uniquement
```

### R√®gle 3 : Advance Action Restrictions

**Apr√®s advance** :
- Seules les armes ASSAULT sont disponibles
- `CAN_ADVANCE = false` (ne peut plus avancer)
- `valid_target_pool` doit √™tre reconstruit avec `arg2=1, arg3=0`

```python
# ‚ùå INTERDIT
def after_advance(unit, game_state):
    unit["CAN_ADVANCE"] = True  # Faux, a d√©j√† avanc√©
    # Utiliser toutes les armes
    weapons = unit["RNG_WEAPONS"]

# ‚úÖ OBLIGATOIRE
def after_advance(unit, game_state):
    unit["CAN_ADVANCE"] = False  # Ne peut plus avancer
    # Filtrer uniquement ASSAULT
    weapon_available_pool = weapon_availability_check(weapon_rule=1, advance_status=1, adjacent_status=0)
    # Reconstruire pool avec restrictions advance
    valid_target_pool = valid_target_pool_build(weapon_rule=1, arg2=1, arg3=0)
```

### R√®gle 4 : Function Arguments Stricts

**`valid_target_pool_build(arg1, arg2, arg3)`** :
- `arg1` : `weapon_rule` (0 ou 1)
- `arg2` : `advance_status` (0=no advance, 1=advanced)
- `arg3` : `adjacent_status` (0=not adjacent, 1=adjacent)

**CRITICAL** : Si `arg2=1` (advanced), alors `arg3` est TOUJOURS 0 (advance restrictions prevent adjacent destinations).

```python
# ‚ùå INTERDIT
valid_target_pool_build(1, 1, 1)  # arg3=1 apr√®s advance = impossible

# ‚úÖ OBLIGATOIRE
if unit_has_advanced:
    valid_target_pool_build(weapon_rule=1, advance_status=1, adjacent_status=0)
```

### R√®gle 5 : End Activation Parameters

**Signature** : `end_activation(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)`

- `Arg1` : `ACTION` | `WAIT` | `NO` | `ERROR`
- `Arg2` : `1` = +step | `0` = pas de step
- `Arg3` : `0` | `SHOOTING` | `ADVANCE` (tracking)
- `Arg4` : `NOT_REMOVED` | `SHOOTING` (pool removal)
- `Arg5` : `1` = log error | `0` = pas de log
- `Arg6` : `1` = remove green circle | `0` = keep circle

```python
# ‚ùå INTERDIT
end_activation("action", 1, "shooting", "shooting", 0, 0)  # Strings au lieu de constantes

# ‚úÖ OBLIGATOIRE
from engine.phase_handlers.shared_utils import ACTION, SHOOTING, NOT_REMOVED
end_activation(ACTION, 1, SHOOTING, SHOOTING, 0, 0)
```

## ‚ö†Ô∏è VIOLATIONS COMMUNES

### Violation 1 : Recalcul Inutile de Caches

```python
# ‚ùå D√âTECTER
def process_shooting(unit, game_state):
    # Recalculer "par s√©curit√©"
    build_units_cache(game_state)  # ERREUR : reset only, pas en phase start
    # ERREUR : current_player n'a pas chang√©, cache toujours valide
```

### Violation 2 : Double Action dans M√™me Phase

```python
# ‚ùå D√âTECTER
unit.shoot()
unit.shoot()  # M√™me unit√© tire deux fois

# ‚úÖ CORRECTION
# units_shot tracking emp√™che cela
assert unit_id not in game_state["units_shot"]
```

### Violation 3 : Tir Apr√®s Advance avec Arme Non-ASSAULT

```python
# ‚ùå D√âTECTER
unit.advance()
shoot_with_any_weapon(unit)  # Pas de filtrage ASSAULT

# ‚úÖ CORRECTION
weapon_available_pool = weapon_availability_check(weapon_rule=1, advance_status=1, adjacent_status=0)
# Filtre automatiquement ASSAULT uniquement
```

## ‚úÖ CHECKLIST DE VALIDATION

Avant de valider un changement dans shooting phase :

- [ ] `current_player` ne change pas pendant la phase (pas de recalcul de caches)
- [ ] Activation s√©quentielle (un seul √† la fois)
- [ ] Caches valides (pas de recalcul inutile)
- [ ] Adjacent = in fight = cannot shoot (sauf PISTOL)
- [ ] Advance restrictions respect√©es (ASSAULT uniquement apr√®s)
- [ ] Arguments de fonctions stricts (arg3=0 si arg2=1)
- [ ] End activation avec bonnes constantes
- [ ] Pas de double action (units_shot tracking)

## üîó R√âF√âRENCES

- **AI_TURN.md** : Section "SHOOTING PHASE Decision Tree" (lignes 364-1256)
- **shooting_handlers.py** : Impl√©mentation de r√©f√©rence
- **shared_utils.py** : Constantes pour end_activation
