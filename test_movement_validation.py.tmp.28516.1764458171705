#!/usr/bin/env python3
"""
Test script to reproduce the movement bug:
- Unit 1 at (23, 7) should NOT be able to move to (23, 2)
- Because enemy Unit 6 is at (23, 6), blocking the path

This simulates the exact scenario from train_step.log
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from engine.phase_handlers import movement_handlers

def test_movement_validation():
    """Test that movement through enemy-adjacent hexes is blocked."""

    # Create game state matching the bug scenario
    # Full wall list from scenario file
    wall_hexes = set([
        (2,5),(2,6),(2,7),(3,4),(4,4),(5,3),(6,3),(7,2),(8,2),(9,1),
        (16,2),(17,2),(18,3),(19,3),(20,4),(21,4),(15,1),(22,5),(22,6),(22,7),
        (2,14),(2,15),(2,13),(3,15),(4,16),(5,16),(6,17),(7,17),(8,18),(9,18),
        (22,13),(22,14),(22,15),(21,15),(20,16),(19,16),(18,17),(17,17),(16,18),(15,18),
        (4,10),(5,10),(6,10),(7,10),(8,10),(8,9),(8,8),(8,7),
        (20,10),(19,9),(18,10),(17,9),(16,10),(16,11),(16,12),(16,13),
        (12,17),(12,16),(12,15),(12,14),(11,13),(10,14),(9,13),(8,14),
        (12,3),(12,4),(12,5),(12,6),(13,6),(14,6),(15,6),(16,6)
    ])
    game_state = {
        "board_cols": 30,
        "board_rows": 20,
        "wall_hexes": wall_hexes,
        "units": [
            {
                "id": "unit_1",
                "player": 0,
                "col": 23,
                "row": 7,
                "HP_CUR": 10,
                "MOVE": 12,  # High movement to reach (23, 2)
                "unitType": "SpaceMarine"
            },
            {
                "id": "unit_6",
                "player": 1,
                "col": 23,
                "row": 6,  # Enemy blocking the path
                "HP_CUR": 10,
                "MOVE": 6,
                "unitType": "Ork"
            }
        ],
        "units_moved": set(),
        "units_fled": set(),
    }

    print("=" * 60)
    print("MOVEMENT VALIDATION TEST")
    print("=" * 60)
    print(f"Unit 1 (player 0) at (23, 7)")
    print(f"Enemy Unit 6 (player 1) at (23, 6)")
    print(f"Testing if Unit 1 can reach (23, 2)")
    print()

    # Build valid destinations using BFS
    movement_handlers.movement_build_valid_destinations_pool(game_state, "unit_1")
    valid_pool = game_state.get("valid_move_destinations_pool", [])

    print(f"Valid destinations pool size: {len(valid_pool)}")

    # Check if (23, 2) is in the pool
    target = (23, 2)
    if target in valid_pool:
        print(f"[INFO] (23, 2) IS in valid pool")

        # Trace possible paths
        print()
        print("Analyzing possible paths from (23,7) to (23,2):")

        # Eastern path check
        east_path = [(23, 7), (24, 8), (25, 8), (25, 7), (25, 6), (25, 5), (24, 5), (24, 4), (23, 4), (23, 3), (23, 2)]
        print(f"  Eastern path ({len(east_path)-1} steps): {east_path}")

        # Check each step for blocking
        blocked_positions = {(23, 5), (24, 6), (24, 7), (23, 7), (22, 7), (22, 6)}  # enemy-adjacent
        wall_positions = game_state["wall_hexes"]
        for i, pos in enumerate(east_path):
            status = []
            if pos in wall_positions:
                status.append("WALL")
            if pos in blocked_positions:
                status.append("ENEMY-ADJ")
            if status:
                print(f"    Step {i}: {pos} - BLOCKED ({', '.join(status)})")
            else:
                print(f"    Step {i}: {pos} - OK")
    else:
        print(f"[OK] (23, 2) is NOT in valid pool - pathfinding correct")

    # Check which positions are reachable along column 23
    print()
    print("Positions reachable along column 23:")
    col_23_reachable = [(c, r) for c, r in valid_pool if c == 23]
    col_23_reachable.sort(key=lambda x: x[1])
    for pos in col_23_reachable:
        print(f"  {pos}")

    # Check which positions are blocked
    print()
    print("Expected blocked hexes (adjacent to enemy at (23,6)):")
    enemy_pos = (23, 6)
    neighbors = movement_handlers._get_hex_neighbors(enemy_pos[0], enemy_pos[1])
    for n in neighbors:
        print(f"  {n} - should be blocked for movement THROUGH")

    # Verify the enemy adjacency blocking
    print()
    print("Testing _is_hex_adjacent_to_enemy:")
    enemy_adjacent_hexes = movement_handlers._build_enemy_adjacent_hexes(game_state, 0)
    print(f"  Enemy adjacent hexes set: {enemy_adjacent_hexes}")

    test_positions = [(23, 5), (23, 7), (22, 6), (24, 6), (22, 5), (24, 5)]
    for pos in test_positions:
        is_adj = movement_handlers._is_hex_adjacent_to_enemy(
            game_state, pos[0], pos[1], 0, enemy_adjacent_hexes
        )
        status = "BLOCKED" if is_adj else "OK"
        print(f"  Position {pos}: {status}")

    print()
    print("=" * 60)

    # Now test the full validation flow
    print("FULL VALIDATION FLOW TEST")
    print("=" * 60)

    # Simulate what happens when AI tries to move to (23, 2)
    action = {
        "action": "move",
        "unitId": "unit_1",
        "destCol": 23,
        "destRow": 2
    }

    # Reset game state for validation
    game_state["valid_move_destinations_pool"] = []

    # Call the destination selection handler directly
    success, result = movement_handlers.movement_destination_selection_handler(
        game_state, "unit_1", action
    )

    print(f"Move to (23, 2) result:")
    print(f"  Success: {success}")
    print(f"  Result: {result}")

    if success:
        print()
        print("[BUG] Movement was ALLOWED when it should be BLOCKED!")
    else:
        print()
        print("[OK] Movement was correctly BLOCKED!")

    return not success  # Return True if test passed (movement blocked)

if __name__ == "__main__":
    passed = test_movement_validation()
    sys.exit(0 if passed else 1)
