# ai/reward_mapper.py
"""
Reward mapping system that implements AI_GAME_OVERVIEW.md specifications
using existing parameter unitTypes from rewards_config.json
"""

from typing import Dict, List, Any, Tuple

class RewardMapper:
    """Maps AI_GAME_OVERVIEW.md tactical priorities to existing reward parameters."""
    
    def __init__(self, rewards_config):
        self.rewards_config = rewards_config
    
    def get_shooting_priority_reward(self, unit, target, all_targets, can_melee_charge_target):
        """
        Calculate shooting reward based on AI_GAME_OVERVIEW.md priority system:
        
        1. Enemy unit at RNG_RNG range:
           - with highest RNG_DMG or CC_DMG score
           - that one or more of our melee units can charge
           - would not kill in 1 melee phase
        
        2. Enemy unit at RNG_RNG range:
           - with highest RNG_DMG or CC_DMG score
           - can be killed by active unit in 1 shooting phase
        
        3. Enemy unit at RNG_RNG range:
           - with highest RNG_DMG or CC_DMG score
           - having the less HP
           - can be killed by active unit in 1 shooting phase
        """
        unit_rewards = self._get_unit_rewards(unit)
        base_actions = unit_rewards.get("base_actions", {})
        if "ranged_attack" not in base_actions:
            raise ValueError("ranged_attack reward not found in unit rewards config")
        base_reward = base_actions["ranged_attack"]
        
        # Calculate target threat score (highest RNG_DMG or CC_DMG)
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        if "RNG_DMG" not in unit:
            raise ValueError(f"unit.RNG_DMG is required for unit {unit.get('unitType', 'unknown')}")
        can_kill_1_phase = target["HP_CUR"] <= unit["RNG_DMG"]
        
        # Priority 1: High threat target that melee can charge but won't kill in 1 melee phase
        if can_melee_charge_target:
            melee_damage = self._get_max_melee_damage_vs_target(target)
            if target["HP_CUR"] > melee_damage:  # Won't be killed by melee in 1 phase
                if self._is_highest_threat_in_range(target, all_targets):
                    if "shoot_priority_1" not in unit_rewards:
                        raise ValueError("shoot_priority_1 reward not found in unit rewards config")
                    return base_reward + unit_rewards["shoot_priority_1"]
        
        # Priority 2: High threat target that can be killed in 1 shooting phase
        if can_kill_1_phase and self._is_highest_threat_in_range(target, all_targets):
            if "shoot_priority_2" not in unit_rewards:
                raise ValueError("shoot_priority_2 reward not found in unit rewards config")
            return base_reward + unit_rewards["shoot_priority_2"]
        
        # Priority 3: High threat, lowest HP target that can be killed in 1 phase
        if can_kill_1_phase and self._is_lowest_hp_high_threat(target, all_targets):
            if "shoot_priority_3" not in unit_rewards:
                raise ValueError("shoot_priority_3 reward not found in unit rewards config")
            return base_reward + unit_rewards["shoot_priority_3"]
        
        # Standard shooting reward
        return base_reward
    
    def get_charge_priority_reward(self, unit, target, all_targets):
        """
        Calculate charge reward based on AI_GAME_OVERVIEW.md priority system:
        
        For melee units:
        1. Enemy with highest threat score that can be killed in 1 melee phase
        2. Enemy with highest threat score, less current HP, HP >= unit's CC_DMG
        3. Enemy with highest threat score and less current HP
        
        For ranged units:
        1. Enemy with highest threat score, highest current HP, can be killed in 1 melee phase
        """
        unit_rewards = self._get_unit_rewards(unit)
        base_actions = unit_rewards.get("base_actions", {})
        if "charge_success" not in base_actions:
            raise ValueError("charge_success reward not found in unit rewards config")
        base_reward = base_actions["charge_success"]

        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        if "CC_DMG" not in unit:
            raise ValueError(f"unit.CC_DMG is required for unit {unit.get('unitType', 'unknown')}")
        can_kill_1_phase = target["HP_CUR"] <= unit["CC_DMG"]
        
        if "is_melee" not in unit:
            raise ValueError(f"unit.is_melee is required for unit {unit.get('unitType', 'unknown')}")
        if unit["is_melee"]:  # Melee unit charge priorities
            # Priority 1: Can kill in 1 melee phase
            if can_kill_1_phase and self._is_highest_threat_in_range(target, all_targets):
                if "charge_priority_1" not in unit_rewards:
                    raise ValueError("charge_priority_1 reward not found in unit rewards config")
                return base_reward + unit_rewards["charge_priority_1"]
            
            # Priority 2: High threat, low HP, HP >= unit's damage
            if (target["HP_CUR"] >= unit["CC_DMG"] and 
                self._is_highest_threat_in_range(target, all_targets) and
                self._is_lowest_hp_among_threats(target, all_targets)):
                if "charge_priority_2" not in unit_rewards:
                    raise ValueError("charge_priority_2 reward not found in unit rewards config")
                return base_reward + unit_rewards["charge_priority_2"]
            
            # Priority 3: High threat, lowest HP
            if (self._is_highest_threat_in_range(target, all_targets) and
                self._is_lowest_hp_among_threats(target, all_targets)):
                if "charge_priority_3" not in unit_rewards:
                    raise ValueError("charge_priority_3 reward not found in unit rewards config")
                return base_reward + unit_rewards["charge_priority_3"]
        
        else:  # Ranged unit charge priorities (different logic)
            if (can_kill_1_phase and 
                self._is_highest_threat_in_range(target, all_targets) and
                self._is_highest_hp_among_threats(target, all_targets)):
                if "charge_priority_1" not in unit_rewards:
                    raise ValueError("charge_priority_1 reward not found in unit rewards config")
                return base_reward + unit_rewards["charge_priority_1"]
        
        return base_reward
    
    def get_combat_priority_reward(self, unit, target, all_targets):
        """
        Calculate combat reward based on AI_GAME_OVERVIEW.md priority system:
        
        1. Enemy with highest threat score that can be killed in 1 melee phase
        2. Enemy with highest threat score, if multiple then lowest current HP
        """
        unit_rewards = self._get_unit_rewards(unit)
        base_actions = unit_rewards.get("base_actions", {})
        if "melee_attack" not in base_actions:
            raise ValueError("melee_attack reward not found in unit rewards config")
        base_reward = base_actions["melee_attack"]

        if "CC_DMG" not in unit:
            raise ValueError(f"unit.CC_DMG is required for unit {unit.get('unitType', 'unknown')}")
        can_kill_1_phase = target["HP_CUR"] <= unit["CC_DMG"]

        # Priority 1: Can kill in 1 melee phase with highest threat
        if can_kill_1_phase and self._is_highest_threat_adjacent(target, all_targets):
            if "attack_priority_1" not in unit_rewards:
                raise ValueError("attack_priority_1 reward not found in unit rewards config")
            return base_reward + unit_rewards["attack_priority_1"]
        
        # Priority 2: Highest threat, lowest HP if multiple high threats
        if (self._is_highest_threat_adjacent(target, all_targets) and
            self._is_lowest_hp_among_adjacent_threats(target, all_targets)):
            if "attack_priority_2" not in unit_rewards:
                raise ValueError("attack_priority_2 reward not found in unit rewards config")
            return base_reward + unit_rewards["attack_priority_2"]
        
        return base_reward
    
    def get_kill_bonus_reward(self, unit, target, damage_dealt):
        """Calculate kill bonus rewards using existing parameter unitTypes."""
        unit_rewards = self._get_unit_rewards(unit)
        
        if target["HP_CUR"] - damage_dealt <= 0:  # Target will be killed
            phase = self._get_current_phase()
            
            result_bonuses = unit_rewards.get("result_bonuses", {})
            if phase == "shoot":
                if "kill_target" not in result_bonuses:
                    raise ValueError("kill_target reward not found in unit rewards config")
                base_kill = result_bonuses["kill_target"]
            else:  # melee combat
                if "kill_target" not in result_bonuses:
                    raise ValueError("kill_target reward not found in unit rewards config")
                base_kill = result_bonuses["kill_target"]
            
            # No overkill bonus
            if target["HP_CUR"] == damage_dealt:
                if phase == "shoot":
                    if "enemy_killed_no_overkill_r" not in unit_rewards:
                        raise ValueError("enemy_killed_no_overkill_r reward not found in unit rewards config")
                    if "enemy_killed_r" not in unit_rewards:
                        raise ValueError("enemy_killed_r reward not found in unit rewards config")
                    base_kill += unit_rewards["enemy_killed_no_overkill_r"] - unit_rewards["enemy_killed_r"]
                else:
                    if "enemy_killed_no_overkill_m" not in unit_rewards:
                        raise ValueError("enemy_killed_no_overkill_m reward not found in unit rewards config")
                    if "enemy_killed_m" not in unit_rewards:
                        raise ValueError("enemy_killed_m reward not found in unit rewards config")
                    base_kill += unit_rewards["enemy_killed_no_overkill_m"] - unit_rewards["enemy_killed_m"]
            
            # Lowest HP target bonus
            if self._was_lowest_hp_target(target):
                if phase == "shoot":
                    if "enemy_killed_lowests_hp_r" not in unit_rewards:
                        raise ValueError("enemy_killed_lowests_hp_r reward not found in unit rewards config")
                    if "enemy_killed_r" not in unit_rewards:
                        raise ValueError("enemy_killed_r reward not found in unit rewards config")
                    base_kill += unit_rewards["enemy_killed_lowests_hp_r"] - unit_rewards["enemy_killed_r"]
                else:
                    if "enemy_killed_lowests_hp_m" not in unit_rewards:
                        raise ValueError("enemy_killed_lowests_hp_m reward not found in unit rewards config")
                    if "enemy_killed_m" not in unit_rewards:
                        raise ValueError("enemy_killed_m reward not found in unit rewards config")
                    base_kill += unit_rewards["enemy_killed_lowests_hp_m"] - unit_rewards["enemy_killed_m"]
            
            return base_kill
        
        raise ValueError("Target was not killed - no kill bonus applicable")
    
    def get_movement_reward(self, unit, old_pos, new_pos, tactical_context):
        """Calculate movement rewards using existing rewards_config.json structure.
        
        Returns:
            tuple: (reward_value, action_name) where action_name is the reward config key
        """
        unit_rewards = self._get_unit_rewards(unit)
        base_actions = unit_rewards["base_actions"]
        tactical_bonuses = unit_rewards.get("tactical_bonuses", {})
        
        if unit.get("is_ranged", False):
            # CHANGE 3: Base movement reward (unchanged)
            if tactical_context.get("moved_to_optimal_range"):
                base_reward = base_actions["move_to_los"]
                action_name = "move_to_los"
            elif tactical_context.get("moved_away"):
                base_reward = base_actions["move_away"]
                action_name = "move_away"
            elif tactical_context.get("moved_closer"):
                base_reward = base_actions["move_close"]
                action_name = "move_close"
            elif tactical_context.get("moved_to_safety"):
                base_reward = base_actions["move_away"]
                action_name = "move_away"
            elif tactical_context.get("moved_to_charge_range"):
                base_reward = base_actions["move_close"]
                action_name = "move_close"
            else:
                raise ValueError("No valid ranged unit movement context found in tactical_context")
            
            # CHANGE 3: Stack tactical bonuses on top of base reward
            total_reward = base_reward
            
            # Bonus 1: Gained LoS on priority target (+0.2)
            if tactical_context.get("gained_los_on_priority_target"):
                total_reward += tactical_bonuses.get("gained_los_on_target", 0.2)
            
            # Bonus 2: Moved to cover from enemies (+0.15)
            if tactical_context.get("moved_to_cover_from_enemies"):
                total_reward += tactical_bonuses.get("moved_to_cover", 0.15)
            
            # Bonus 3: Safe from enemy charges (+0.1)
            if tactical_context.get("safe_from_enemy_charges"):
                total_reward += tactical_bonuses.get("safe_from_charges", 0.1)
            
            # Bonus 4: Safe from enemy ranged (+0.05 - secondary benefit)
            if tactical_context.get("safe_from_enemy_ranged"):
                total_reward += tactical_bonuses.get("safe_from_ranged", 0.05)
            
            return (total_reward, action_name)
        else:
            # Melee unit movement priorities using existing config keys
            if tactical_context.get("moved_to_charge_range"):
                return (base_actions["move_to_charge"], "move_to_charge")
            elif tactical_context.get("moved_closer"):
                return (base_actions["move_close"], "move_close")
            elif tactical_context.get("moved_away"):
                return (base_actions["move_away"], "move_away")
            else:
                raise ValueError("No valid melee unit movement context found in tactical_context")
    
    def _get_unit_rewards(self, unit):
        """Get reward configuration using unit naming convention."""
        unit_type = unit.get("unitType", "unknown")

        # Direct lookup using exact unit type from rewards_config.json
        if unit_type in self.rewards_config:
            return self.rewards_config[unit_type]

        # If exact match not found, raise error with available keys for debugging
        available_keys = list(self.rewards_config.keys())
        raise ValueError(f"Unit type '{unit_type}' not found in rewards_config. Available keys: {available_keys}")
    
    def _parse_unit_type(self, unit_type: str) -> Dict[str, str]:
        """Parse unit type into components: Faction_Movement_PowerLevel_AttackPreference
        Also handles phase-specific suffixes like _phase1, _phase2, etc."""
        parts = unit_type.split("_")
        
        # Strip phase suffix if present (e.g., "phase1", "phase2", "phase3")
        if len(parts) > 4 and parts[-1].startswith("phase"):
            parts = parts[:-1]
        
        if len(parts) != 4:
            raise ValueError(f"Invalid unit type format: {unit_type}. Expected: Faction_Movement_PowerLevel_AttackPreference")
        
        return {
            "faction": parts[0],      # SpaceMarine, Tyranid
            "movement": parts[1],     # Infantry, Vehicle
            "power_level": parts[2],  # Swarm, Troop, Elite, Leader
            "attack_pref": parts[3]   # RangedSwarm, MeleeElite, etc.
        }
    
    def _get_target_type_bonus(self, unit: Dict[str, Any], target: Dict[str, Any]) -> float:
        """Calculate target type bonus based on unit's attack preference vs target's characteristics."""
        unit_rewards = self._get_unit_rewards(unit)
        target_bonuses = unit_rewards.get("target_type_bonuses", {})
        
        # Parse both unit and target types
        unit_parsed = self._parse_unit_type(unit.get("unitType", ""))
        target_parsed = self._parse_unit_type(target.get("unitType", ""))
        
        total_bonus = 0.0
        
        # Attack preference vs target power level match
        attack_pref = unit_parsed["attack_pref"]
        target_power = target_parsed["power_level"]
        
        # Extract preferred target type from attack preference
        if "Swarm" in attack_pref:
            preferred_target = "swarm"
        elif "Troop" in attack_pref:
            preferred_target = "troop"
        elif "Elite" in attack_pref:
            preferred_target = "elite"
        elif "Leader" in attack_pref:
            preferred_target = "leader"
        else:
            preferred_target = "troop"  # Default
        
        # Calculate penalty for targeting non-preferred types
        target_power_lower = target_power.lower()
        if f"vs_{target_power_lower}" in target_bonuses:
            total_bonus += target_bonuses[f"vs_{target_power_lower}"]
        
        # Attack type vs target type
        if "Ranged" in attack_pref:
            if f"vs_ranged" in target_bonuses:
                total_bonus += target_bonuses["vs_ranged"]
        elif "Melee" in attack_pref:
            if f"vs_melee" in target_bonuses:
                total_bonus += target_bonuses["vs_melee"]
        
        return total_bonus
    
    def _is_highest_threat_in_range(self, target, all_targets):
        """Check if target has highest threat score among all targets in range."""
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        for other in all_targets:
            if other != target:
                if "RNG_DMG" not in other or "CC_DMG" not in other:
                    raise ValueError(f"other target missing required damage fields: {other['unitType']}")
                other_threat = max(other["RNG_DMG"], other["CC_DMG"])
                if other_threat > target_threat:
                    return False
        return True
    
    def _is_highest_threat_adjacent(self, target, adjacent_targets):
        """Check if target has highest threat score among adjacent targets."""
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        for other in adjacent_targets:
            if other != target:
                if "RNG_DMG" not in other or "CC_DMG" not in other:
                    raise ValueError(f"other target missing required damage fields: {other['unitType']}")
                other_threat = max(other["RNG_DMG"], other["CC_DMG"])
                if other_threat > target_threat:
                    return False
        return True
    
    def _is_lowest_hp_high_threat(self, target, all_targets):
        """Check if target has lowest HP among high threat targets."""
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        max_threat = max(max(t["RNG_DMG"], t["CC_DMG"]) for t in all_targets 
                        if "RNG_DMG" in t and "CC_DMG" in t)
        
        if target_threat == max_threat:
            for other in all_targets:
                if "RNG_DMG" not in other or "CC_DMG" not in other:
                    raise ValueError(f"other target missing required damage fields: {other['unitType']}")
                other_threat = max(other["RNG_DMG"], other["CC_DMG"])
                if other_threat == max_threat and other["HP_CUR"] < target["HP_CUR"]:
                    return False
            return True
        return False
    
    def _is_lowest_hp_among_threats(self, target, all_targets):
        """Check if target has lowest HP among targets of same threat level.""" 
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        for other in all_targets:
            if "RNG_DMG" not in other or "CC_DMG" not in other:
                raise ValueError(f"other target missing required damage fields: {other.get('unitType', 'unknown')}")
            other_threat = max(other["RNG_DMG"], other["CC_DMG"])
            if other_threat == target_threat and other["HP_CUR"] < target["HP_CUR"]:
                return False
        return True
    
    def _is_highest_hp_among_threats(self, target, all_targets):
        """Check if target has highest HP among targets of same threat level."""
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        for other in all_targets:
            if "RNG_DMG" not in other or "CC_DMG" not in other:
                raise ValueError(f"other target missing required damage fields: {other.get('unitType', 'unknown')}")
            other_threat = max(other["RNG_DMG"], other["CC_DMG"])
            if other_threat == target_threat and other["HP_CUR"] > target["HP_CUR"]:
                return False
        return True
    
    def _is_lowest_hp_among_adjacent_threats(self, target, adjacent_targets):
        """Check if target has lowest HP among adjacent targets of same threat level."""
        if "RNG_DMG" not in target:
            raise ValueError(f"target.RNG_DMG is required for unit {target['unitType']}")
        if "CC_DMG" not in target:
            raise ValueError(f"target.CC_DMG is required for unit {target['unitType']}")
        target_threat = max(target["RNG_DMG"], target["CC_DMG"])
        for other in adjacent_targets:
            if other != target:
                if "RNG_DMG" not in other or "CC_DMG" not in other:
                    raise ValueError(f"other target missing required damage fields: {other['unitType']}")
                other_threat = max(other["RNG_DMG"], other["CC_DMG"])
                if other_threat == target_threat and other["HP_CUR"] < target["HP_CUR"]:
                    return False
        return True
    
    def _get_max_melee_damage_vs_target(self, target):
        """Get maximum melee damage our units can do to target.""" 
        # This would need access to friendly units list
        # Throw error instead of using default - no fallbacks allowed
        raise NotImplementedError("_get_max_melee_damage_vs_target requires access to friendly units list - no fallback defaults allowed")
    
    def _get_current_phase(self):
        """Get current game phase."""
        # This would need access to game state
        raise NotImplementedError("_get_current_phase requires access to game state - no fallback defaults allowed")
    
    def _was_lowest_hp_target(self, target):
        """Check if this was the lowest HP target when action was taken."""
        # This would need access to game state at time of action
        raise NotImplementedError("_was_lowest_hp_target requires access to game state at action time - no fallback defaults allowed")